{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Android MCP SDK","text":"<p>An Android library that integrates the MCP Kotlin SDK to enable Android applications to host an MCP server.</p>"},{"location":"#overview","title":"Overview","text":"<p>The Android MCP SDK provides a comprehensive solution for integrating Model Context Protocol capabilities into Android applications. This enables your Android apps to expose tools, resources, and prompts that can be accessed by AI tools and development environments via adb-connected workstations.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u2705 Full MCP specification support (tools, resources, prompts)</li> <li>\u2705 Built-in Android-specific tools and resources</li> <li>\u2705 WebSocket and HTTP/SSE transport layers</li> <li>\u2705 AndroidX Startup automatic initialization</li> <li>\u2705 Thread-safe singleton management</li> <li>\u2705 Comprehensive lifecycle management</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Add the library to your Android project:</p> <pre><code>dependencies {\n    implementation(\"dev.jasonpearson:mcp-android-sdk:1.0.0\")\n}\n</code></pre> <p>Initialize in your Application class:</p> <pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // MCP server is automatically initialized via AndroidX Startup\n        if (McpStartup.isInitialized()) {\n            val manager = McpStartup.getManager()\n            manager.startServerAsync()\n        }\n    }\n}\n</code></pre>"},{"location":"#what-is-mcp","title":"What is MCP?","text":"<p>The Model Context Protocol (MCP) is an open standard that enables AI applications to securely connect to and interact with local and remote resources. It provides a standardized way for AI tools to:</p> <ul> <li>Call functions (tools) to perform actions</li> <li>Access data (resources) in various formats</li> <li>Generate prompts with dynamic templates</li> </ul>"},{"location":"#android-integration","title":"Android Integration","text":"<p>This SDK brings MCP to Android by:</p> <ol> <li>Hosting MCP servers within Android applications</li> <li>Exposing Android-specific capabilities as MCP tools and resources</li> <li>Enabling remote access via adb port forwarding</li> <li>Providing seamless integration with existing Android development workflows</li> </ol>"},{"location":"#architecture","title":"Architecture","text":"<pre><code>graph TB\n    A[AI Tool/Client] --&gt;|adb forward| B[Development Workstation]\n    B --&gt;|WebSocket/HTTP| C[Android Device]\n    C --&gt; D[Your Android App]\n    D --&gt; E[Android MCP SDK]\n    E --&gt; F[MCP Server]\n    F --&gt; G[Tools]\n    F --&gt; H[Resources] \n    F --&gt; I[Prompts]\n    G --&gt; J[Device Info]\n    G --&gt; K[App Data]\n    G --&gt; L[File Operations]\n    H --&gt; M[Config Files]\n    H --&gt; N[Database]\n    H --&gt; O[Real-time Status]</code></pre>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#development-and-debugging","title":"Development and Debugging","text":"<ul> <li>App introspection: Expose app state and configuration to AI tools</li> <li>Log analysis: Provide structured access to application logs</li> <li>Performance monitoring: Real-time metrics and diagnostics</li> <li>Configuration management: Dynamic configuration updates</li> </ul>"},{"location":"#ai-assisted-development","title":"AI-Assisted Development","text":"<ul> <li>Code generation: Context-aware Android code generation</li> <li>Test creation: Automated test suite generation</li> <li>Code review: AI-powered code quality analysis</li> <li>Documentation: Generate documentation from code and usage patterns</li> </ul>"},{"location":"#data-access","title":"Data Access","text":"<ul> <li>Database queries: Expose app database contents</li> <li>File system: Controlled access to app files and resources</li> <li>Network data: API responses and cached data</li> <li>User preferences: App settings and user data</li> </ul>"},{"location":"#transport-layers","title":"Transport Layers","text":"<p>The SDK supports multiple transport mechanisms for different use cases:</p>"},{"location":"#websocket-transport-port-8080","title":"WebSocket Transport (Port 8080)","text":"<ul> <li>Real-time bidirectional communication</li> <li>Ideal for interactive AI tools</li> <li>Low latency for rapid tool execution</li> </ul>"},{"location":"#httpsse-transport-port-8081","title":"HTTP/SSE Transport (Port 8081)","text":"<ul> <li>HTTP request/response pattern</li> <li>Server-Sent Events for notifications</li> <li>Easy integration with web-based tools</li> </ul>"},{"location":"#built-in-capabilities","title":"Built-in Capabilities","text":""},{"location":"#android-tools","title":"Android Tools","text":"<ul> <li>Device Information: Model, manufacturer, Android version</li> <li>Application Info: Package details, version, permissions</li> <li>System Metrics: Memory usage, battery status, system time</li> <li>File Operations: Secure file access within app boundaries</li> </ul>"},{"location":"#android-resources","title":"Android Resources","text":"<ul> <li>App Configuration: Settings and preferences</li> <li>Device Status: Real-time system information</li> <li>Database Access: Structured data exposure</li> <li>File Resources: Documents and media files</li> </ul>"},{"location":"#development-prompts","title":"Development Prompts","text":"<ul> <li>Log Analysis: Automated log parsing and issue detection</li> <li>Code Generation: Android-specific code templates</li> <li>Error Explanation: Context-aware error resolution</li> <li>Test Creation: Comprehensive test suite generation</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to integrate MCP into your Android app? Follow these guides:</p> <ol> <li>Getting Started - Installation and basic setup</li> <li>Usage Guide - Adding tools, resources, and prompts</li> <li>Transport Configuration - WebSocket and HTTP setup</li> <li>API Reference - Complete API documentation</li> </ol>"},{"location":"#project-goals","title":"Project Goals","text":"<p>The Android MCP SDK enables Android developers to:</p> <ul> <li>Bridge the gap between AI tools and Android development</li> <li>Expose app capabilities through standardized protocols</li> <li>Enhance development workflows with AI assistance</li> <li>Provide secure access to app data and functionality</li> </ul> <p>By implementing MCP in Android applications, developers can create powerful integrations with AI tools, enabling more intelligent and context-aware development experiences.</p>"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>GitHub Repository: android-mcp-sdk</li> <li>MCP Specification: modelcontextprotocol.io</li> <li>MCP Kotlin SDK: kotlin-sdk</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/","title":"Complete MCP Server Wrapper Implementation","text":"<p>This document describes the complete MCP Server wrapper implementation for Android, which provides a robust integration layer between Android applications and the MCP (Model Context Protocol) Kotlin SDK.</p>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#overview","title":"Overview","text":"<p>The Android MCP SDK now provides a complete server wrapper implementation that:</p> <ul> <li>\u2705 Integrates with MCP Kotlin SDK: Uses the official MCP Kotlin SDK v0.5.0</li> <li>\u2705 Provides Android-specific tools: Device info, app info, system time, memory info, battery   info</li> <li>\u2705 Supports MCP protocol features: Tools, Resources, Prompts</li> <li>\u2705 Thread-safe singleton management: Centralized server lifecycle management</li> <li>\u2705 Graceful fallback: Works even if SDK integration fails</li> <li>\u2705 AndroidX Startup integration: Automatic initialization</li> <li>\u2705 Comprehensive error handling: Robust error management and logging</li> </ul>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#architecture","title":"Architecture","text":""},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#core-components","title":"Core Components","text":""},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#1-mcpandroidserver","title":"1. McpAndroidServer","text":"<p>The main server wrapper class that provides:</p> <pre><code>class McpAndroidServer {\n    // Core functionality\n    fun initialize(): Result&lt;Unit&gt;\n    suspend fun start(): Result&lt;Unit&gt;\n    suspend fun stop(): Result&lt;Unit&gt;\n\n    // Server status\n    fun isRunning(): Boolean\n    fun isInitialized(): Boolean\n    fun hasSDKIntegration(): Boolean\n\n    // Android-specific tools\n    fun getAvailableTools(): List&lt;AndroidTool&gt;\n    suspend fun executeTool(toolName: String, arguments: Map&lt;String, Any&gt;): ToolExecutionResult\n    fun addTool(tool: AndroidTool)\n\n    // MCP SDK integration\n    fun getMcpTools(): List&lt;io.modelcontextprotocol.kotlin.sdk.Tool&gt;\n    suspend fun callMcpTool(name: String, arguments: Map&lt;String, Any&gt;): CallToolResult\n    fun getMcpResources(): List&lt;io.modelcontextprotocol.kotlin.sdk.Resource&gt;\n    fun getMcpPrompts(): List&lt;io.modelcontextprotocol.kotlin.sdk.Prompt&gt;\n}\n</code></pre>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#2-mcpservermanager","title":"2. McpServerManager","text":"<p>Thread-safe singleton manager that provides centralized access:</p> <pre><code>class McpServerManager {\n    // Initialization\n    fun initialize(context: Context, serverName: String, serverVersion: String): Result&lt;Unit&gt;\n\n    // Server lifecycle\n    suspend fun startServer(): Result&lt;Unit&gt;\n    suspend fun stopServer(): Result&lt;Unit&gt;\n    fun startServerAsync(): Job?\n\n    // Status and information\n    fun isInitialized(): Boolean\n    fun isServerRunning(): Boolean\n    fun hasSDKIntegration(): Boolean\n    fun getServerInfo(): ServerInfo?\n    fun getComprehensiveServerInfo(): ComprehensiveServerInfo?\n\n    // Tool operations\n    fun getAndroidTools(): List&lt;AndroidTool&gt;\n    suspend fun executeAndroidTool(name: String, arguments: Map&lt;String, Any&gt;): ToolExecutionResult\n    fun getMcpTools(): List&lt;Tool&gt;\n    suspend fun callMcpTool(name: String, arguments: Map&lt;String, Any&gt;): CallToolResult\n}\n</code></pre>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#3-feature-providers","title":"3. Feature Providers","text":"<p>Specialized providers for different MCP capabilities:</p> <ul> <li>ToolProvider: Manages Android-specific and MCP tools</li> <li>ResourceProvider: Handles file system and app data resources</li> <li>PromptProvider: Manages prompt templates</li> </ul>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#sdk-integration-strategy","title":"SDK Integration Strategy","text":"<p>The implementation uses a multi-layered approach to SDK integration:</p> <ol> <li>Primary Integration: Direct use of MCP Kotlin SDK classes</li> <li>Reflection Fallback: Uses reflection for cases with import conflicts</li> <li>Graceful Degradation: Falls back to Android-only functionality if SDK fails</li> </ol> <pre><code>private fun createMcpServerWithSDK(): Any? {\n    return try {\n        // Create server using reflection to avoid import conflicts\n        val serverClass = Class.forName(\"io.modelcontextprotocol.kotlin.sdk.server.Server\")\n        val implementationClass = Class.forName(\"io.modelcontextprotocol.kotlin.sdk.Implementation\")\n        // ... reflection-based instantiation\n    } catch (e: Exception) {\n        Log.w(TAG, \"Reflection-based server creation failed\", e)\n        null\n    }\n}\n</code></pre>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#built-in-android-tools","title":"Built-in Android Tools","text":"<p>The server comes with several built-in Android-specific tools:</p>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#1-device-info-tool","title":"1. Device Info Tool","text":"<pre><code>{\n    \"name\": \"device_info\",\n    \"description\": \"Get information about the Android device\",\n    \"parameters\": {}\n}\n</code></pre> <p>Returns comprehensive device information including model, manufacturer, Android version, API level, etc.</p>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#2-app-info-tool","title":"2. App Info Tool","text":"<pre><code>{\n    \"name\": \"app_info\", \n    \"description\": \"Get information about the current application\",\n    \"parameters\": {\n        \"package_name\": {\n            \"type\": \"string\",\n            \"description\": \"Package name of the app (optional)\"\n        }\n    }\n}\n</code></pre> <p>Provides application details like version, package name, target SDK, etc.</p>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#3-system-time-tool","title":"3. System Time Tool","text":"<pre><code>{\n    \"name\": \"system_time\",\n    \"description\": \"Get current system time in various formats\",\n    \"parameters\": {\n        \"format\": {\n            \"type\": \"string\",\n            \"enum\": [\"iso\", \"timestamp\", \"readable\"],\n            \"default\": \"iso\"\n        },\n        \"timezone\": {\n            \"type\": \"string\", \n            \"description\": \"Timezone (optional)\"\n        }\n    }\n}\n</code></pre>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#4-memory-info-tool","title":"4. Memory Info Tool","text":"<pre><code>{\n    \"name\": \"memory_info\",\n    \"description\": \"Get current memory usage information\",\n    \"parameters\": {}\n}\n</code></pre> <p>Provides system and app memory usage statistics.</p>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#5-battery-info-tool","title":"5. Battery Info Tool","text":"<pre><code>{\n    \"name\": \"battery_info\",\n    \"description\": \"Get current battery status and information\", \n    \"parameters\": {}\n}\n</code></pre> <p>Returns battery level, charging status, health, temperature, etc.</p>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#usage-examples","title":"Usage Examples","text":""},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#basic-setup-with-androidx-startup-automatic","title":"Basic Setup with AndroidX Startup (Automatic)","text":"<p>The simplest way to use the MCP server is with automatic initialization:</p> <pre><code>class MyActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Server is automatically initialized via AndroidX Startup\n        if (McpStartup.isInitialized()) {\n            val manager = McpStartup.getManager()\n            Log.i(\"MCP\", \"SDK Version: ${manager.getMcpSdkVersion()}\")\n\n            // Start the server\n            lifecycleScope.launch {\n                manager.startServer()\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#manual-initialization","title":"Manual Initialization","text":"<p>For more control over the initialization:</p> <pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        val manager = McpServerManager.getInstance()\n        manager.initialize(\n            context = this,\n            serverName = \"My Android MCP Server\",\n            serverVersion = \"2.0.0\"\n        ).onSuccess {\n            Log.i(\"MCP\", \"Server initialized successfully\")\n        }.onFailure { exception -&gt;\n            Log.e(\"MCP\", \"Failed to initialize server\", exception)\n        }\n    }\n}\n</code></pre>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#using-android-tools","title":"Using Android Tools","text":"<pre><code>// Get all available Android tools\nval tools = manager.getAndroidTools()\ntools.forEach { tool -&gt;\n    Log.i(\"MCP\", \"Available tool: ${tool.name} - ${tool.description}\")\n}\n\n// Execute a tool\nval result = manager.executeAndroidTool(\"device_info\", emptyMap())\nif (result.success) {\n    Log.i(\"MCP\", \"Device info: ${result.result}\")\n} else {\n    Log.e(\"MCP\", \"Tool execution failed: ${result.error}\")\n}\n</code></pre>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#adding-custom-tools","title":"Adding Custom Tools","text":"<pre><code>// Add a custom Android tool\nmanager.addAndroidTool(\n    AndroidTool(\n        name = \"custom_action\",\n        description = \"Perform a custom action\",\n        parameters = mapOf(\"action\" to \"string\")\n    ) { context, arguments -&gt;\n        val action = arguments[\"action\"] as? String ?: \"default\"\n        \"Performed action: $action on ${context.packageName}\"\n    }\n)\n</code></pre>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#using-mcp-sdk-features","title":"Using MCP SDK Features","text":"<pre><code>// Get MCP tools (if SDK integration is available)\nif (manager.hasSDKIntegration()) {\n    val mcpTools = manager.getMcpTools()\n    val mcpResources = manager.getMcpResources()\n    val mcpPrompts = manager.getMcpPrompts()\n\n    // Call an MCP tool\n    val result = manager.callMcpTool(\"device_info\", emptyMap())\n    if (!result.isError) {\n        Log.i(\"MCP\", \"MCP tool result: ${result.content}\")\n    }\n}\n</code></pre>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#transport-layer","title":"Transport Layer","text":"<p>The implementation includes a transport layer for communication:</p>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#androidstdiotransport","title":"AndroidStdioTransport","text":"<pre><code>class AndroidStdioTransport {\n    fun createTransport(): StdioServerTransport\n    fun isRunning(): Boolean\n    fun stop()\n}\n</code></pre> <p>This transport enables communication via standard input/output, which can be accessed through adb shell connections.</p>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#error-handling-and-logging","title":"Error Handling and Logging","text":"<p>The implementation provides comprehensive error handling:</p> <ul> <li>Graceful fallbacks: Continues working even if SDK integration fails</li> <li>Detailed logging: Comprehensive logging at different levels (DEBUG, INFO, WARN, ERROR)</li> <li>Result types: Uses Kotlin's <code>Result&lt;T&gt;</code> type for error-safe operations</li> <li>Exception isolation: Prevents exceptions from crashing the app</li> </ul>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#configuration-and-capabilities","title":"Configuration and Capabilities","text":""},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#server-capabilities","title":"Server Capabilities","text":"<p>The server supports all major MCP capabilities:</p> <pre><code>ServerCapabilities(\n    tools = ToolsCapability(listChanged = true),\n    resources = ResourcesCapability(\n        subscribe = true,\n        listChanged = true\n    ),\n    prompts = PromptsCapability(listChanged = true)\n)\n</code></pre>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#server-information","title":"Server Information","text":"<p>Comprehensive server information is available:</p> <pre><code>data class ComprehensiveServerInfo(\n    val name: String,\n    val version: String,\n    val sdkVersion: String,\n    val isRunning: Boolean,\n    val isInitialized: Boolean,\n    val capabilities: ServerCapabilities,\n    val toolCount: Int,\n    val resourceCount: Int,\n    val promptCount: Int,\n    val rootCount: Int\n)\n</code></pre>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#thread-safety","title":"Thread Safety","text":"<p>All public APIs are thread-safe:</p> <ul> <li>AtomicBoolean for state management</li> <li>Synchronized blocks for critical sections</li> <li>ConcurrentHashMap for tool storage</li> <li>Coroutine-safe operations</li> </ul>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#testing-support","title":"Testing Support","text":"<p>The implementation includes testing utilities:</p> <pre><code>// For testing only - resets the singleton\nMcpServerManager.getInstance().resetForTesting()\n</code></pre>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#future-enhancements","title":"Future Enhancements","text":"<p>Planned improvements include:</p> <ol> <li>Complete STDIO transport integration for adb communication</li> <li>WebSocket transport for network communication</li> <li>File system resources with proper Android permissions</li> <li>Database resources for app data access</li> <li>Custom prompt templates for specific use cases</li> <li>Sampling support for advanced client communication</li> </ol>"},{"location":"COMPLETE_MCP_SERVER_WRAPPER/#benefits","title":"Benefits","text":"<p>This complete implementation provides:</p> <ul> <li>Easy integration: Simple APIs for Android developers</li> <li>Robust error handling: Graceful degradation and comprehensive logging</li> <li>SDK compatibility: Full integration with MCP Kotlin SDK</li> <li>Android optimization: Tailored for Android development patterns</li> <li>Extensibility: Easy to add custom tools, resources, and prompts</li> <li>Production ready: Thread-safe, well-tested, and documented</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete API reference for the Android MCP SDK, covering all public classes, methods, and interfaces.</p>"},{"location":"api-reference/#core-classes","title":"Core Classes","text":""},{"location":"api-reference/#mcpstartup","title":"McpStartup","text":"<p>Utility class providing convenient access to MCP server functionality.</p>"},{"location":"api-reference/#static-methods","title":"Static Methods","text":""},{"location":"api-reference/#isinitialized-boolean","title":"<code>isInitialized(): Boolean</code>","text":"<p>Check if the MCP server has been initialized.</p> <pre><code>if (McpStartup.isInitialized()) {\n    // Server is ready to use\n}\n</code></pre>"},{"location":"api-reference/#getmanager-mcpservermanager","title":"<code>getManager(): McpServerManager</code>","text":"<p>Get the singleton instance of the MCP server manager.</p> <pre><code>val manager = McpStartup.getManager()\n</code></pre> <p>Throws: <code>IllegalStateException</code> if not initialized</p>"},{"location":"api-reference/#initializemanuallycontext-context-mcpservermanager","title":"<code>initializeManually(context: Context): McpServerManager</code>","text":"<p>Manually initialize the MCP server with default configuration.</p> <pre><code>val manager = McpStartup.initializeManually(context)\n</code></pre> <p>Parameters:</p> <ul> <li><code>context</code>: Android Context (Application or Activity)</li> </ul> <p>Returns: Configured McpServerManager instance</p>"},{"location":"api-reference/#_1","title":"API Reference","text":"<p><code>initializeWithCustomConfig(context: Context, serverName: String, serverVersion: String): Result&lt;McpServerManager&gt;</code></p> <p>Initialize with custom server configuration.</p> <pre><code>val result = McpStartup.initializeWithCustomConfig(\n    context = this,\n    serverName = \"My Custom Server\",\n    serverVersion = \"2.0.0\"\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>context</code>: Android Context</li> <li><code>serverName</code>: Custom server name</li> <li><code>serverVersion</code>: Custom server version</li> </ul> <p>Returns: Result containing McpServerManager or error</p>"},{"location":"api-reference/#mcpservermanager","title":"McpServerManager","text":"<p>Thread-safe singleton for managing MCP server lifecycle and operations.</p>"},{"location":"api-reference/#server-lifecycle","title":"Server Lifecycle","text":""},{"location":"api-reference/#initializecontext-context-servername-string-serverversion-string-resultunit","title":"<code>initialize(context: Context, serverName: String?, serverVersion: String?): Result&lt;Unit&gt;</code>","text":"<p>Initialize the server with optional custom configuration.</p> <pre><code>manager.initialize(\n    context = applicationContext,\n    serverName = \"My App Server\",\n    serverVersion = \"1.0.0\"\n).onSuccess {\n    Log.d(\"MCP\", \"Server initialized\")\n}.onFailure { error -&gt;\n    Log.e(\"MCP\", \"Initialization failed\", error)\n}\n</code></pre>"},{"location":"api-reference/#startserver-resultunit","title":"<code>startServer(): Result&lt;Unit&gt;</code>","text":"<p>Start the MCP server (suspending function).</p> <pre><code>lifecycleScope.launch {\n    manager.startServer().getOrThrow()\n}\n</code></pre>"},{"location":"api-reference/#startserverasync","title":"<code>startServerAsync()</code>","text":"<p>Start the MCP server asynchronously (non-blocking).</p> <pre><code>manager.startServerAsync()\n</code></pre>"},{"location":"api-reference/#stopserver-resultunit","title":"<code>stopServer(): Result&lt;Unit&gt;</code>","text":"<p>Stop the MCP server (suspending function).</p> <pre><code>lifecycleScope.launch {\n    manager.stopServer().getOrThrow()\n}\n</code></pre>"},{"location":"api-reference/#isserverrunning-boolean","title":"<code>isServerRunning(): Boolean</code>","text":"<p>Check if the server is currently running.</p> <pre><code>val running = manager.isServerRunning()\n</code></pre>"},{"location":"api-reference/#server-information","title":"Server Information","text":""},{"location":"api-reference/#getmcpsdkversion-string","title":"<code>getMcpSdkVersion(): String</code>","text":"<p>Get the version of the integrated MCP SDK.</p> <pre><code>val version = manager.getMcpSdkVersion()\n</code></pre>"},{"location":"api-reference/#gettransportinfo-string","title":"<code>getTransportInfo(): String</code>","text":"<p>Get information about transport layer configuration.</p> <pre><code>val info = manager.getTransportInfo()\nLog.d(\"MCP\", \"Transport: $info\")\n</code></pre>"},{"location":"api-reference/#hassdkintegration-boolean","title":"<code>hasSDKIntegration(): Boolean</code>","text":"<p>Check if MCP SDK integration is available.</p> <pre><code>if (manager.hasSDKIntegration()) {\n    // Full MCP features available\n}\n</code></pre>"},{"location":"api-reference/#tool-management","title":"Tool Management","text":""},{"location":"api-reference/#_2","title":"API Reference","text":"<p><code>addSimpleTool(name: String, description: String, parameters: Map&lt;String, String&gt;, handler: (Map&lt;String, Any&gt;) -&gt; String)</code></p> <p>Add a simple tool with minimal configuration.</p> <pre><code>manager.addSimpleTool(\n    name = \"calculate\",\n    description = \"Perform calculations\",\n    parameters = mapOf(\"operation\" to \"string\", \"a\" to \"number\", \"b\" to \"number\")\n) { args -&gt;\n    val op = args[\"operation\"] as String\n    val a = (args[\"a\"] as Number).toDouble()\n    val b = (args[\"b\"] as Number).toDouble()\n\n    when (op) {\n        \"add\" -&gt; \"Result: ${a + b}\"\n        \"multiply\" -&gt; \"Result: ${a * b}\"\n        else -&gt; \"Unknown operation\"\n    }\n}\n</code></pre>"},{"location":"api-reference/#addmcptooltool-tool-handler-mapstring-any-calltoolresult","title":"<code>addMcpTool(tool: Tool, handler: (Map&lt;String, Any&gt;) -&gt; CallToolResult)</code>","text":"<p>Add a full MCP tool with complete schema support.</p> <pre><code>val tool = Tool(\n    name = \"advanced_tool\",\n    description = \"Advanced tool with full schema\",\n    inputSchema = Tool.Input(\n        properties = buildJsonObject { /* schema */ },\n        required = listOf(\"param1\")\n    )\n)\n\nmanager.addMcpTool(tool) { args -&gt;\n    CallToolResult(\n        content = listOf(TextContent(text = \"Result\")),\n        isError = false\n    )\n}\n</code></pre>"},{"location":"api-reference/#executeandroidtoolname-string-arguments-mapstring-any-androidtoolresult","title":"<code>executeAndroidTool(name: String, arguments: Map&lt;String, Any&gt;): AndroidToolResult</code>","text":"<p>Execute a built-in Android tool.</p> <pre><code>val result = manager.executeAndroidTool(\"device_info\", emptyMap())\nLog.d(\"MCP\", \"Device info: ${result.result}\")\n</code></pre>"},{"location":"api-reference/#resource-management","title":"Resource Management","text":""},{"location":"api-reference/#_3","title":"API Reference","text":"<p><code>addFileResource(uri: String, name: String, description: String, filePath: String, mimeType: String)</code></p> <p>Add a file-based resource.</p> <pre><code>manager.addFileResource(\n    uri = \"app://config/settings.json\",\n    name = \"App Settings\",\n    description = \"Application settings\",\n    filePath = File(context.filesDir, \"settings.json\").absolutePath,\n    mimeType = \"application/json\"\n)\n</code></pre>"},{"location":"api-reference/#addmcpresourceresource-resource-provider-androidresourcecontent","title":"<code>addMcpResource(resource: Resource, provider: () -&gt; AndroidResourceContent)</code>","text":"<p>Add a dynamic MCP resource.</p> <pre><code>val resource = Resource(\n    uri = \"app://status\",\n    name = \"App Status\",\n    description = \"Real-time app status\"\n)\n\nmanager.addMcpResource(resource) {\n    AndroidResourceContent(\n        uri = \"app://status\",\n        text = getCurrentStatus(),\n        mimeType = \"application/json\"\n    )\n}\n</code></pre>"},{"location":"api-reference/#subscribemcpresourceuri-string","title":"<code>subscribeMcpResource(uri: String)</code>","text":"<p>Subscribe to resource updates.</p> <pre><code>manager.subscribeMcpResource(\"app://status\")\n</code></pre>"},{"location":"api-reference/#prompt-management","title":"Prompt Management","text":""},{"location":"api-reference/#_4","title":"API Reference","text":"<p><code>addSimplePrompt(name: String, description: String, arguments: List&lt;PromptArgument&gt;, generator: (Map&lt;String, Any&gt;) -&gt; String)</code></p> <p>Add a simple prompt template.</p> <pre><code>manager.addSimplePrompt(\n    name = \"code_review\",\n    description = \"Generate code review\",\n    arguments = listOf(\n        PromptArgument(\"code\", \"Code to review\", required = true),\n        PromptArgument(\"language\", \"Programming language\", required = false)\n    )\n) { args -&gt;\n    val code = args[\"code\"] as String\n    val language = args[\"language\"] as? String ?: \"kotlin\"\n\n    \"Please review this $language code:\\n\\n```$language\\n$code\\n```\"\n}\n</code></pre>"},{"location":"api-reference/#addmcppromptprompt-prompt-generator-mapstring-any-getpromptresult","title":"<code>addMcpPrompt(prompt: Prompt, generator: (Map&lt;String, Any&gt;) -&gt; GetPromptResult)</code>","text":"<p>Add a full MCP prompt.</p> <pre><code>val prompt = Prompt(\n    name = \"advanced_prompt\",\n    description = \"Advanced prompt with multiple messages\",\n    arguments = listOf(/* arguments */)\n)\n\nmanager.addMcpPrompt(prompt) { args -&gt;\n    GetPromptResult(\n        description = \"Generated prompt\",\n        messages = listOf(\n            PromptMessage(\n                role = MessageRole.USER,\n                content = TextContent(text = \"Generated content\")\n            )\n        )\n    )\n}\n</code></pre>"},{"location":"api-reference/#getmcppromptname-string-arguments-mapstring-any-getpromptresult","title":"<code>getMcpPrompt(name: String, arguments: Map&lt;String, Any&gt;): GetPromptResult</code>","text":"<p>Get a prompt with specified arguments (suspending function).</p> <pre><code>lifecycleScope.launch {\n    val result = manager.getMcpPrompt(\"code_review\", mapOf(\"code\" to sourceCode))\n    Log.d(\"MCP\", \"Prompt: ${result.description}\")\n}\n</code></pre>"},{"location":"api-reference/#lifecycle-management","title":"Lifecycle Management","text":""},{"location":"api-reference/#_5","title":"API Reference","text":"<p><code>initializeLifecycleManagement(application: Application, config: McpLifecycleManager.LifecycleConfig)</code></p> <p>Initialize lifecycle management.</p> <pre><code>manager.initializeLifecycleManagement(\n    application = this,\n    config = McpLifecycleManager.LifecycleConfig(\n        autoStartOnAppStart = true,\n        autoStopOnAppStop = false,\n        restartOnAppReturn = true,\n        pauseOnBackground = false,\n        stopOnLastActivityDestroyed = false\n    )\n)\n</code></pre>"},{"location":"api-reference/#getlifecyclestate-mcplifecyclemanagerlifecyclestate","title":"<code>getLifecycleState(): McpLifecycleManager.LifecycleState</code>","text":"<p>Get current lifecycle state.</p> <pre><code>val state = manager.getLifecycleState()\nLog.d(\"MCP\", \"In background: ${state.isAppInBackground}\")\nLog.d(\"MCP\", \"Active activities: ${state.activeActivities}\")\n</code></pre>"},{"location":"api-reference/#updatelifecycleconfigconfig-mcplifecyclemanagerlifecycleconfig","title":"<code>updateLifecycleConfig(config: McpLifecycleManager.LifecycleConfig)</code>","text":"<p>Update lifecycle configuration.</p> <pre><code>manager.updateLifecycleConfig(\n    manager.getLifecycleState().config.copy(\n        autoStopOnAppStop = false\n    )\n)\n</code></pre>"},{"location":"api-reference/#transport-layer","title":"Transport Layer","text":""},{"location":"api-reference/#broadcastmessagemessage-string","title":"<code>broadcastMessage(message: String)</code>","text":"<p>Broadcast a message to all connected clients (suspending function).</p> <pre><code>lifecycleScope.launch {\n    manager.broadcastMessage(\"\"\"{\"jsonrpc\":\"2.0\",\"method\":\"notification\",\"params\":{}}\"\"\")\n}\n</code></pre>"},{"location":"api-reference/#data-classes","title":"Data Classes","text":""},{"location":"api-reference/#tool","title":"Tool","text":"<p>Represents an MCP tool definition.</p> <pre><code>data class Tool(\n    val name: String,\n    val description: String,\n    val inputSchema: Input\n) {\n    data class Input(\n        val type: String = \"object\",\n        val properties: JsonObject,\n        val required: List&lt;String&gt; = emptyList()\n    )\n}\n</code></pre> <p>Example:</p> <pre><code>val tool = Tool(\n    name = \"my_tool\",\n    description = \"Tool description\",\n    inputSchema = Tool.Input(\n        properties = buildJsonObject {\n            put(\"param1\", buildJsonObject {\n                put(\"type\", JsonPrimitive(\"string\"))\n                put(\"description\", JsonPrimitive(\"Parameter description\"))\n            })\n        },\n        required = listOf(\"param1\")\n    )\n)\n</code></pre>"},{"location":"api-reference/#resource","title":"Resource","text":"<p>Represents an MCP resource.</p> <pre><code>data class Resource(\n    val uri: String,\n    val name: String,\n    val description: String,\n    val mimeType: String? = null\n)\n</code></pre>"},{"location":"api-reference/#prompt","title":"Prompt","text":"<p>Represents an MCP prompt template.</p> <pre><code>data class Prompt(\n    val name: String,\n    val description: String,\n    val arguments: List&lt;PromptArgument&gt; = emptyList()\n)\n</code></pre>"},{"location":"api-reference/#promptargument","title":"PromptArgument","text":"<p>Represents a prompt argument.</p> <pre><code>data class PromptArgument(\n    val name: String,\n    val description: String,\n    val required: Boolean = false\n)\n</code></pre>"},{"location":"api-reference/#calltoolresult","title":"CallToolResult","text":"<p>Result of a tool execution.</p> <pre><code>data class CallToolResult(\n    val content: List&lt;McpContent&gt;,\n    val isError: Boolean = false\n)\n</code></pre>"},{"location":"api-reference/#androidresourcecontent","title":"AndroidResourceContent","text":"<p>Content for Android-specific resources.</p> <pre><code>data class AndroidResourceContent(\n    val uri: String,\n    val text: String? = null,\n    val blob: ByteArray? = null,\n    val mimeType: String? = null\n)\n</code></pre>"},{"location":"api-reference/#getpromptresult","title":"GetPromptResult","text":"<p>Result of prompt generation.</p> <pre><code>data class GetPromptResult(\n    val description: String,\n    val messages: List&lt;PromptMessage&gt;\n)\n</code></pre>"},{"location":"api-reference/#promptmessage","title":"PromptMessage","text":"<p>Message within a prompt.</p> <pre><code>data class PromptMessage(\n    val role: MessageRole,\n    val content: McpContent\n)\n</code></pre>"},{"location":"api-reference/#enums","title":"Enums","text":""},{"location":"api-reference/#messagerole","title":"MessageRole","text":"<p>Roles for prompt messages.</p> <pre><code>enum class MessageRole {\n    USER,\n    ASSISTANT\n}\n</code></pre>"},{"location":"api-reference/#content-types","title":"Content Types","text":""},{"location":"api-reference/#mcpcontent","title":"McpContent","text":"<p>Base interface for MCP content.</p> <pre><code>sealed interface McpContent\n</code></pre>"},{"location":"api-reference/#textcontent","title":"TextContent","text":"<p>Text-based content.</p> <pre><code>data class TextContent(\n    val text: String\n) : McpContent\n</code></pre>"},{"location":"api-reference/#imagecontent","title":"ImageContent","text":"<p>Image-based content.</p> <pre><code>data class ImageContent(\n    val data: String,\n    val mimeType: String\n) : McpContent\n</code></pre>"},{"location":"api-reference/#configuration-classes","title":"Configuration Classes","text":""},{"location":"api-reference/#mcplifecyclemanagerlifecycleconfig","title":"McpLifecycleManager.LifecycleConfig","text":"<p>Configuration for lifecycle management.</p> <pre><code>data class LifecycleConfig(\n    val autoStartOnAppStart: Boolean = true,\n    val autoStopOnAppStop: Boolean = true,\n    val restartOnAppReturn: Boolean = false,\n    val pauseOnBackground: Boolean = false,\n    val stopOnLastActivityDestroyed: Boolean = true\n)\n</code></pre>"},{"location":"api-reference/#mcplifecyclemanagerlifecyclestate","title":"McpLifecycleManager.LifecycleState","text":"<p>Current lifecycle state information.</p> <pre><code>data class LifecycleState(\n    val isAppInBackground: Boolean,\n    val activeActivities: Int,\n    val isServerRunning: Boolean,\n    val config: LifecycleConfig\n)\n</code></pre>"},{"location":"api-reference/#built-in-tools","title":"Built-in Tools","text":"<p>The SDK provides several built-in Android tools:</p>"},{"location":"api-reference/#device_info","title":"device_info","text":"<p>Get comprehensive device information.</p> <pre><code>val result = manager.executeAndroidTool(\"device_info\", emptyMap())\n</code></pre> <p>Returns: JSON with device model, manufacturer, Android version, etc.</p>"},{"location":"api-reference/#app_info","title":"app_info","text":"<p>Get application information.</p> <pre><code>val result = manager.executeAndroidTool(\"app_info\", emptyMap())\n</code></pre> <p>Returns: JSON with app name, version, package name, etc.</p>"},{"location":"api-reference/#system_time","title":"system_time","text":"<p>Get current system time in various formats.</p> <pre><code>val result = manager.executeAndroidTool(\"system_time\", emptyMap())\n</code></pre> <p>Returns: JSON with timestamp, formatted time, timezone, etc.</p>"},{"location":"api-reference/#memory_info","title":"memory_info","text":"<p>Get system and app memory information.</p> <pre><code>val result = manager.executeAndroidTool(\"memory_info\", emptyMap())\n</code></pre> <p>Returns: JSON with memory usage statistics.</p>"},{"location":"api-reference/#battery_info","title":"battery_info","text":"<p>Get battery status and information.</p> <pre><code>val result = manager.executeAndroidTool(\"battery_info\", emptyMap())\n</code></pre> <p>Returns: JSON with battery level, charging status, health, etc.</p>"},{"location":"api-reference/#built-in-resources","title":"Built-in Resources","text":""},{"location":"api-reference/#androidappinfo","title":"android://app/info","text":"<p>Application information resource.</p>"},{"location":"api-reference/#androiddeviceinfo","title":"android://device/info","text":"<p>Device information resource.</p>"},{"location":"api-reference/#built-in-prompts","title":"Built-in Prompts","text":""},{"location":"api-reference/#analyze_android_log","title":"analyze_android_log","text":"<p>Analyze Android logs for issues.</p> <p>Arguments:</p> <ul> <li><code>log_content</code> (required): Log content to analyze</li> <li><code>focus_area</code> (optional): Specific area to focus on</li> </ul>"},{"location":"api-reference/#generate_android_code","title":"generate_android_code","text":"<p>Generate Android code with best practices.</p> <p>Arguments:</p> <ul> <li><code>description</code> (required): What to generate</li> <li><code>language</code> (optional): Programming language (default: kotlin)</li> </ul>"},{"location":"api-reference/#explain_android_error","title":"explain_android_error","text":"<p>Explain and provide solutions for Android errors.</p> <p>Arguments:</p> <ul> <li><code>error_message</code> (required): Error message or stack trace</li> <li><code>context</code> (optional): Additional context</li> </ul>"},{"location":"api-reference/#create_android_test","title":"create_android_test","text":"<p>Create comprehensive test suites.</p> <p>Arguments:</p> <ul> <li><code>component</code> (required): Component to test</li> <li><code>test_type</code> (optional): Type of test (unit, integration, ui)</li> </ul>"},{"location":"api-reference/#review_android_code","title":"review_android_code","text":"<p>Review code for quality and best practices.</p> <p>Arguments:</p> <ul> <li><code>code</code> (required): Code to review</li> <li><code>focus</code> (optional): Areas to focus on</li> </ul>"},{"location":"api-reference/#error-handling","title":"Error Handling","text":"<p>All async operations return <code>Result&lt;T&gt;</code> for safe error handling:</p> <pre><code>manager.startServer().fold(\n    onSuccess = { \n        Log.d(\"MCP\", \"Server started successfully\")\n    },\n    onFailure = { error -&gt;\n        Log.e(\"MCP\", \"Failed to start server\", error)\n    }\n)\n</code></pre> <p>Common exceptions:</p> <ul> <li><code>IllegalStateException</code>: Server not initialized</li> <li><code>IllegalArgumentException</code>: Invalid parameters</li> <li><code>IOException</code>: Network or file I/O errors</li> </ul>"},{"location":"api-reference/#threading","title":"Threading","text":"<ul> <li>All manager methods are thread-safe</li> <li>Suspending functions should be called from coroutines</li> <li>Async methods handle threading internally</li> </ul>"},{"location":"api-reference/#best-practices","title":"Best Practices","text":"<ol> <li>Use Result handling: Always handle success/failure cases</li> <li>Lifecycle management: Configure appropriate lifecycle behavior</li> <li>Resource cleanup: Stop server when appropriate</li> <li>Error logging: Log errors for debugging</li> <li>Validation: Validate tool inputs and resource URIs</li> </ol>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you set up the Android MCP SDK in your Android project and get your first MCP server running.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Android Studio Arctic Fox or later</li> <li>Minimum SDK 29 (Android 10)</li> <li>Kotlin 1.9.0 or later</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#gradle-setup","title":"Gradle Setup","text":"<p>Add the library to your app's <code>build.gradle.kts</code>:</p> <pre><code>dependencies {\n    implementation(\"dev.jasonpearson:mcp-android-sdk:1.0.0\")\n}\n</code></pre> <p>Or if using Groovy:</p> <pre><code>dependencies {\n    implementation 'dev.jasonpearson:mcp-android-sdk:1.0.0'\n}\n</code></pre>"},{"location":"getting-started/#version-catalog-recommended","title":"Version Catalog (Recommended)","text":"<p>Add to your <code>gradle/libs.versions.toml</code>:</p> <pre><code>[versions]\nmcpAndroidSdk = \"1.0.0\"\n\n[libraries]\nmcp-android-sdk = { module = \"dev.jasonpearson:mcp-android-sdk\", version.ref = \"mcpAndroidSdk\" }\n</code></pre> <p>Then in your <code>build.gradle.kts</code>:</p> <pre><code>dependencies {\n    implementation(libs.mcp.android.sdk)\n}\n</code></pre>"},{"location":"getting-started/#quick-setup","title":"Quick Setup","text":""},{"location":"getting-started/#option-1-automatic-initialization-recommended","title":"Option 1: Automatic Initialization (Recommended)","text":"<p>The simplest way to get started is to let the library automatically initialize itself:</p> <pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // MCP server is automatically initialized via AndroidX Startup\n        if (McpStartup.isInitialized()) {\n            val manager = McpStartup.getManager()\n\n            // Start the server when app starts\n            manager.startServerAsync()\n\n            Log.i(\"MCP\", \"MCP Server started automatically\")\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/#option-2-manual-initialization","title":"Option 2: Manual Initialization","text":"<p>If you need more control over when the server initializes:</p> <pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // Manual initialization\n        val manager = McpStartup.initializeManually(this)\n\n        // Start the server\n        lifecycleScope.launch {\n            manager.startServer().getOrThrow()\n            Log.i(\"MCP\", \"MCP Server started manually\")\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/#option-3-custom-configuration","title":"Option 3: Custom Configuration","text":"<p>For advanced configuration:</p> <pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        val result = McpStartup.initializeWithCustomConfig(\n            context = this,\n            serverName = \"My Android App MCP Server\",\n            serverVersion = \"1.0.0\"\n        )\n\n        result.fold(\n            onSuccess = { manager -&gt;\n                Log.i(\"MCP\", \"Custom MCP server initialized\")\n\n                // Configure lifecycle management\n                manager.initializeLifecycleManagement(\n                    application = this,\n                    config = McpLifecycleManager.LifecycleConfig(\n                        autoStartOnAppStart = true,\n                        autoStopOnAppStop = false,\n                        restartOnAppReturn = true\n                    )\n                )\n\n                // Start server\n                manager.startServerAsync()\n            },\n            onFailure = { exception -&gt;\n                Log.e(\"MCP\", \"Failed to initialize MCP server\", exception)\n            }\n        )\n    }\n}\n</code></pre>"},{"location":"getting-started/#manifest-configuration","title":"Manifest Configuration","text":""},{"location":"getting-started/#automatic-configuration","title":"Automatic Configuration","text":"<p>By default, the library automatically configures AndroidX Startup. No manifest changes are needed.</p>"},{"location":"getting-started/#custom-manifest-configuration","title":"Custom Manifest Configuration","text":"<p>If you need to customize the initialization:</p> <pre><code>&lt;application&gt;\n    &lt;provider\n        android:name=\"androidx.startup.InitializationProvider\"\n        android:authorities=\"${applicationId}.androidx-startup\"\n        android:exported=\"false\"\n        tools:node=\"merge\"&gt;\n        &lt;meta-data\n            android:name=\"dev.jasonpearson.mcpandroidsdk.McpServerManagerInitializer\"\n            android:value=\"androidx.startup\" /&gt;\n    &lt;/provider&gt;\n&lt;/application&gt;\n</code></pre>"},{"location":"getting-started/#disabling-automatic-initialization","title":"Disabling Automatic Initialization","text":"<p>To disable automatic initialization:</p> <pre><code>&lt;application&gt;\n    &lt;provider\n        android:name=\"androidx.startup.InitializationProvider\"\n        android:authorities=\"${applicationId}.androidx-startup\"\n        android:exported=\"false\"\n        tools:node=\"merge\"&gt;\n        &lt;meta-data\n            android:name=\"dev.jasonpearson.mcpandroidsdk.McpServerManagerInitializer\"\n            tools:node=\"remove\" /&gt;\n    &lt;/provider&gt;\n&lt;/application&gt;\n</code></pre>"},{"location":"getting-started/#first-steps","title":"First Steps","text":""},{"location":"getting-started/#check-server-status","title":"Check Server Status","text":"<p>After initialization, you can check if everything is working:</p> <pre><code>class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Check if MCP is initialized\n        if (McpStartup.isInitialized()) {\n            val manager = McpStartup.getManager()\n\n            Log.d(\"MCP\", \"Server running: ${manager.isServerRunning()}\")\n            Log.d(\"MCP\", \"SDK version: ${manager.getMcpSdkVersion()}\")\n\n            // Get transport information\n            val transportInfo = manager.getTransportInfo()\n            Log.d(\"MCP\", \"Transport info: $transportInfo\")\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/#test-built-in-tools","title":"Test Built-in Tools","text":"<p>The SDK comes with several built-in Android tools you can test:</p> <pre><code>lifecycleScope.launch {\n    val manager = McpStartup.getManager()\n\n    // Test device info tool\n    val deviceInfo = manager.executeAndroidTool(\"device_info\", emptyMap())\n    Log.d(\"MCP\", \"Device info: ${deviceInfo.result}\")\n\n    // Test app info tool\n    val appInfo = manager.executeAndroidTool(\"app_info\", emptyMap())\n    Log.d(\"MCP\", \"App info: ${appInfo.result}\")\n}\n</code></pre>"},{"location":"getting-started/#testing-your-setup","title":"Testing Your Setup","text":""},{"location":"getting-started/#using-adb-port-forwarding","title":"Using adb Port Forwarding","text":"<p>To test your MCP server from your development machine:</p> <pre><code># Forward the default MCP ports\nadb forward tcp:8080 tcp:8080  # WebSocket\nadb forward tcp:8081 tcp:8081  # HTTP/SSE\n\n# Test the HTTP endpoint\ncurl http://localhost:8081/mcp/status\n\n# Test WebSocket connection (using a WebSocket client)\n# Connect to: ws://localhost:8080/mcp\n</code></pre>"},{"location":"getting-started/#using-the-sample-app","title":"Using the Sample App","text":"<p>The repository includes a sample app that demonstrates all features:</p> <pre><code># Build and install the sample app\n./gradlew :sample:assembleDebug\n./gradlew :sample:installDebug\n\n# Check logs for MCP initialization\nadb logcat | grep MCP\n</code></pre>"},{"location":"getting-started/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/#initialization-fails","title":"Initialization Fails","text":"<p>If initialization fails, check:</p> <ol> <li>Minimum SDK: Ensure your app targets API 29 or higher</li> <li>AndroidX Startup: Make sure AndroidX Startup is properly configured</li> <li>Permissions: Check if any additional permissions are needed</li> </ol>"},{"location":"getting-started/#server-wont-start","title":"Server Won't Start","text":"<p>If the server won't start:</p> <ol> <li>Check logs: Look for error messages in Logcat</li> <li>Port conflicts: Ensure ports 8080 and 8081 aren't being used by other apps</li> <li>Lifecycle state: Make sure your app is in the foreground</li> </ol>"},{"location":"getting-started/#transport-issues","title":"Transport Issues","text":"<p>If you can't connect to the server:</p> <ol> <li>Port forwarding: Verify adb port forwarding is set up correctly</li> <li>Firewall: Check if any firewall is blocking the connections</li> <li>Network: Ensure your development machine can reach the Android device</li> </ol>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Once you have the basic setup working:</p> <ol> <li>Add Custom Tools - Create your own MCP tools</li> <li>Configure Resources - Expose app data as MCP resources</li> <li>Set Up Transports - Configure WebSocket and HTTP transports</li> <li>Explore Examples - See comprehensive usage examples</li> </ol>"},{"location":"getting-started/#integration-status","title":"Integration Status","text":"<p>Current integration features:</p> <ul> <li>\u2705 MCP Kotlin SDK: Version 0.5.0 integrated</li> <li>\u2705 Dependencies: Both main and JVM artifacts included</li> <li>\u2705 Project Structure: Kotlin sources organized properly</li> <li>\u2705 Compilation: Library compiles successfully</li> <li>\u2705 Singleton Manager: Thread-safe singleton implementation</li> <li>\u2705 AndroidX Startup: Full automatic initialization support</li> </ul>"},{"location":"getting-started/#dependencies","title":"Dependencies","text":"<p>The library includes these dependencies automatically:</p> <ul> <li><code>io.modelcontextprotocol:kotlin-sdk:0.5.0</code> - Main MCP Kotlin SDK</li> <li><code>io.modelcontextprotocol:kotlin-sdk-jvm:0.5.0</code> - JVM-specific implementation</li> <li><code>androidx.startup:startup-runtime:1.2.0</code> - AndroidX Startup for initialization</li> </ul>"},{"location":"transport/","title":"Transport Configuration","text":"<p>The Android MCP SDK supports multiple transport layers for communication between your Android app and MCP clients. This guide covers configuration and usage of the available transport options.</p>"},{"location":"transport/#overview","title":"Overview","text":"<p>The SDK provides two main transport mechanisms:</p> <ul> <li>WebSocket Transport: Real-time bidirectional communication (default port: 8080)</li> <li>HTTP/SSE Transport: HTTP-based communication with Server-Sent Events (default port: 8081)</li> </ul> <p>Both transports are automatically started when the MCP server starts and can be accessed via adb port forwarding from your development workstation.</p>"},{"location":"transport/#websocket-transport","title":"WebSocket Transport","text":""},{"location":"transport/#default-configuration","title":"Default Configuration","text":"<p>WebSocket transport is automatically configured and started:</p> <pre><code>val manager = McpStartup.getManager()\n\n// Start server (WebSocket transport starts automatically)\nmanager.startServerAsync()\n\n// Check transport status\nval transportInfo = manager.getTransportInfo()\nLog.d(\"MCP\", \"WebSocket endpoint: ws://localhost:8080/mcp\")\n</code></pre>"},{"location":"transport/#connecting-from-development-machine","title":"Connecting from Development Machine","text":"<p>Set up adb port forwarding to access the WebSocket from your workstation:</p> <pre><code># Forward WebSocket port\nadb forward tcp:8080 tcp:8080\n\n# Connect using a WebSocket client\n# Endpoint: ws://localhost:8080/mcp\n</code></pre>"},{"location":"transport/#sending-custom-messages","title":"Sending Custom Messages","text":"<p>You can broadcast custom messages to all connected WebSocket clients:</p> <pre><code>lifecycleScope.launch {\n    val manager = McpStartup.getManager()\n\n    // Send a custom notification\n    val message = buildJsonObject {\n        put(\"jsonrpc\", JsonPrimitive(\"2.0\"))\n        put(\"method\", JsonPrimitive(\"notification/custom\"))\n        put(\"params\", buildJsonObject {\n            put(\"type\", JsonPrimitive(\"status_update\"))\n            put(\"message\", JsonPrimitive(\"Server status changed\"))\n            put(\"timestamp\", JsonPrimitive(System.currentTimeMillis()))\n        })\n    }\n\n    manager.broadcastMessage(message.toString())\n}\n</code></pre>"},{"location":"transport/#websocket-client-example","title":"WebSocket Client Example","text":"<p>Example WebSocket client code (JavaScript):</p> <pre><code>// Connect to Android MCP server via adb forwarding\nconst ws = new WebSocket('ws://localhost:8080/mcp');\n\nws.onopen = function() {\n    console.log('Connected to Android MCP server');\n\n    // Send tools/list request\n    ws.send(JSON.stringify({\n        jsonrpc: \"2.0\",\n        method: \"tools/list\",\n        id: 1\n    }));\n};\n\nws.onmessage = function(event) {\n    const response = JSON.parse(event.data);\n    console.log('Received:', response);\n};\n\nws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n};\n</code></pre>"},{"location":"transport/#httpsse-transport","title":"HTTP/SSE Transport","text":""},{"location":"transport/#default-configuration_1","title":"Default Configuration","text":"<p>HTTP/SSE transport provides HTTP endpoints for request/response and Server-Sent Events for server-to-client communication:</p> <pre><code>// HTTP/SSE transport is automatically available when server starts\nval manager = McpStartup.getManager()\nmanager.startServerAsync()\n\n// Available endpoints:\n// POST http://localhost:8081/mcp/message - Client-to-server messages\n// GET  http://localhost:8081/mcp/events  - Server-to-client events (SSE)\n// GET  http://localhost:8081/mcp/status  - Transport status\n</code></pre>"},{"location":"transport/#connecting-from-development-machine_1","title":"Connecting from Development Machine","text":"<p>Set up adb port forwarding for HTTP/SSE:</p> <pre><code># Forward HTTP/SSE port\nadb forward tcp:8081 tcp:8081\n\n# Test the status endpoint\ncurl http://localhost:8081/mcp/status\n\n# Send a message\ncurl -X POST http://localhost:8081/mcp/message \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1}'\n\n# Listen to server events (SSE)\ncurl -N http://localhost:8081/mcp/events\n</code></pre>"},{"location":"transport/#http-client-example","title":"HTTP Client Example","text":"<p>Example HTTP client implementation (Python):</p> <pre><code>import requests\nimport json\nfrom sseclient import SSEClient\n\n# Base URL for Android MCP server via adb forwarding\nBASE_URL = \"http://localhost:8081/mcp\"\n\n# Send request to server\ndef send_request(method, params=None, request_id=1):\n    payload = {\n        \"jsonrpc\": \"2.0\",\n        \"method\": method,\n        \"id\": request_id\n    }\n    if params:\n        payload[\"params\"] = params\n\n    response = requests.post(\n        f\"{BASE_URL}/message\",\n        json=payload,\n        headers={\"Content-Type\": \"application/json\"}\n    )\n    return response.json()\n\n# Listen to server events\ndef listen_to_events():\n    messages = SSEClient(f\"{BASE_URL}/events\")\n    for msg in messages:\n        if msg.data:\n            event = json.loads(msg.data)\n            print(f\"Received event: {event}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    # Get available tools\n    tools_response = send_request(\"tools/list\")\n    print(\"Available tools:\", tools_response)\n\n    # Call a tool\n    device_info = send_request(\"tools/call\", {\n        \"name\": \"device_info\",\n        \"arguments\": {}\n    })\n    print(\"Device info:\", device_info)\n\n    # Start listening to events (in a separate thread)\n    import threading\n    event_thread = threading.Thread(target=listen_to_events)\n    event_thread.daemon = True\n    event_thread.start()\n</code></pre>"},{"location":"transport/#transport-security","title":"Transport Security","text":""},{"location":"transport/#network-security","title":"Network Security","text":"<p>When using transport layers, consider these security aspects:</p> <ol> <li>Local Network Only: Transports are bound to localhost and only accessible via adb forwarding</li> <li>Development Use: Intended for development and debugging, not production exposure</li> <li>Firewall: Ensure your development machine firewall allows the forwarded ports</li> </ol>"},{"location":"transport/#authentication","title":"Authentication","text":"<p>Currently, the transport layers don't include built-in authentication. For production use, consider:</p> <ol> <li>VPN: Use VPN connections for remote access</li> <li>Tunnel: Use secure tunneling solutions</li> <li>Custom Auth: Implement custom authentication in your tools and resources</li> </ol>"},{"location":"transport/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"transport/#custom-port-configuration","title":"Custom Port Configuration","text":"<p>While the default ports work for most use cases, you can check the current configuration:</p> <pre><code>val manager = McpStartup.getManager()\nval transportInfo = manager.getTransportInfo()\n\nLog.d(\"MCP\", \"Transport configuration: $transportInfo\")\n// Will show current port assignments and status\n</code></pre>"},{"location":"transport/#connection-management","title":"Connection Management","text":"<p>Monitor and manage transport connections:</p> <pre><code>class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val manager = McpStartup.getManager()\n\n        // Monitor transport status\n        lifecycleScope.launch {\n            while (isActive) {\n                val transportInfo = manager.getTransportInfo()\n                Log.d(\"MCP\", \"Transport status: $transportInfo\")\n\n                // Check if transports are healthy\n                if (!transportInfo.contains(\"running\")) {\n                    Log.w(\"MCP\", \"Transport may be down, attempting restart\")\n                    manager.startServerAsync()\n                }\n\n                delay(30000) // Check every 30 seconds\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"transport/#troubleshooting","title":"Troubleshooting","text":""},{"location":"transport/#common-issues","title":"Common Issues","text":""},{"location":"transport/#port-forwarding-not-working","title":"Port Forwarding Not Working","text":"<pre><code># Check if adb is connected\nadb devices\n\n# Remove existing forwards and re-add\nadb forward --remove tcp:8080\nadb forward --remove tcp:8081\nadb forward tcp:8080 tcp:8080\nadb forward tcp:8081 tcp:8081\n\n# Verify forwards are active\nadb forward --list\n</code></pre>"},{"location":"transport/#connection-refused","title":"Connection Refused","text":"<ol> <li> <p>Check if server is running:    <pre><code>val manager = McpStartup.getManager()\nLog.d(\"MCP\", \"Server running: ${manager.isServerRunning()}\")\n</code></pre></p> </li> <li> <p>Check device logs:    <pre><code>adb logcat | grep MCP\n</code></pre></p> </li> <li> <p>Verify app is in foreground: Some lifecycle configurations may pause the server when app is    backgrounded</p> </li> </ol>"},{"location":"transport/#websocket-connection-drops","title":"WebSocket Connection Drops","text":"<p>WebSocket connections may drop due to:</p> <ol> <li>App lifecycle changes: Configure lifecycle management to handle background states</li> <li>Network changes: WiFi/mobile network switches</li> <li>Device sleep: Android's Doze mode or app standby</li> </ol> <p>Solution:</p> <pre><code>// Configure lifecycle to keep server running\nmanager.initializeLifecycleManagement(\n    application = this,\n    config = McpLifecycleManager.LifecycleConfig(\n        autoStartOnAppStart = true,\n        autoStopOnAppStop = false,  // Keep running in background\n        restartOnAppReturn = true\n    )\n)\n</code></pre>"},{"location":"transport/#debugging-transport-issues","title":"Debugging Transport Issues","text":""},{"location":"transport/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<pre><code>// In your Application class\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // Enable debug logging for transport issues\n        if (BuildConfig.DEBUG) {\n            Log.d(\"MCP\", \"Starting MCP server with debug logging\")\n        }\n\n        val manager = McpStartup.initializeManually(this)\n        manager.startServerAsync()\n    }\n}\n</code></pre>"},{"location":"transport/#test-transport-endpoints","title":"Test Transport Endpoints","text":"<pre><code>#!/bin/bash\n# test_transport.sh - Script to test all transport endpoints\n\necho \"Testing Android MCP Transport Endpoints\"\necho \"=======================================\"\n\n# Setup port forwarding\nadb forward tcp:8080 tcp:8080\nadb forward tcp:8081 tcp:8081\n\necho \"1. Testing HTTP Status Endpoint\"\ncurl -s http://localhost:8081/mcp/status | jq .\n\necho -e \"\\n2. Testing WebSocket Connection\"\n# Note: Requires websocat tool (cargo install websocat)\necho '{\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1}' | \\\n  timeout 5s websocat ws://localhost:8080/mcp\n\necho -e \"\\n3. Testing HTTP Message Endpoint\"\ncurl -s -X POST http://localhost:8081/mcp/message \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1}' | jq .\n\necho -e \"\\nTransport test complete!\"\n</code></pre>"},{"location":"transport/#performance-considerations","title":"Performance Considerations","text":""},{"location":"transport/#connection-limits","title":"Connection Limits","text":"<p>The transport layer can handle multiple simultaneous connections, but consider:</p> <ol> <li>Memory usage: Each connection consumes memory</li> <li>CPU overhead: Message processing for multiple clients</li> <li>Battery impact: Network activity affects battery life</li> </ol>"},{"location":"transport/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Batch operations: Group multiple requests when possible</li> <li>Efficient JSON: Minimize JSON payload sizes</li> <li>Connection reuse: Reuse WebSocket connections for multiple requests</li> <li>Background management: Properly handle app lifecycle transitions</li> </ol>"},{"location":"transport/#monitoring-performance","title":"Monitoring Performance","text":"<pre><code>class TransportMonitor {\n    private val messageCount = AtomicInteger(0)\n    private val lastResetTime = AtomicLong(System.currentTimeMillis())\n\n    fun onMessageReceived() {\n        messageCount.incrementAndGet()\n\n        val now = System.currentTimeMillis()\n        val elapsed = now - lastResetTime.get()\n\n        // Log stats every minute\n        if (elapsed &gt; 60000) {\n            val messagesPerMinute = messageCount.get()\n            Log.d(\"MCP\", \"Transport stats: $messagesPerMinute messages/minute\")\n\n            messageCount.set(0)\n            lastResetTime.set(now)\n        }\n    }\n}\n</code></pre>"},{"location":"transport/#integration-examples","title":"Integration Examples","text":""},{"location":"transport/#claude-desktop-integration","title":"Claude Desktop Integration","text":"<p>Configure Claude Desktop to connect to your Android MCP server:</p> <pre><code>{\n  \"mcpServers\": {\n    \"android-app\": {\n      \"command\": \"node\",\n      \"args\": [\"path/to/websocket-mcp-client.js\"],\n      \"env\": {\n        \"ANDROID_MCP_URL\": \"ws://localhost:8080/mcp\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"transport/#custom-mcp-client","title":"Custom MCP Client","text":"<p>Build a custom MCP client that connects to your Android server:</p> <pre><code>// mcp-android-client.js\nconst WebSocket = require('ws');\n\nclass AndroidMCPClient {\n    constructor(url = 'ws://localhost:8080/mcp') {\n        this.url = url;\n        this.ws = null;\n        this.requestId = 1;\n        this.pendingRequests = new Map();\n    }\n\n    async connect() {\n        this.ws = new WebSocket(this.url);\n\n        this.ws.on('message', (data) =&gt; {\n            const message = JSON.parse(data.toString());\n            this.handleMessage(message);\n        });\n\n        return new Promise((resolve, reject) =&gt; {\n            this.ws.on('open', resolve);\n            this.ws.on('error', reject);\n        });\n    }\n\n    async callTool(name, arguments = {}) {\n        const id = this.requestId++;\n        const request = {\n            jsonrpc: \"2.0\",\n            method: \"tools/call\",\n            params: { name, arguments },\n            id\n        };\n\n        return this.sendRequest(request);\n    }\n\n    async listTools() {\n        const id = this.requestId++;\n        const request = {\n            jsonrpc: \"2.0\",\n            method: \"tools/list\",\n            id\n        };\n\n        return this.sendRequest(request);\n    }\n\n    sendRequest(request) {\n        return new Promise((resolve, reject) =&gt; {\n            this.pendingRequests.set(request.id, { resolve, reject });\n            this.ws.send(JSON.stringify(request));\n        });\n    }\n\n    handleMessage(message) {\n        if (message.id &amp;&amp; this.pendingRequests.has(message.id)) {\n            const { resolve, reject } = this.pendingRequests.get(message.id);\n            this.pendingRequests.delete(message.id);\n\n            if (message.error) {\n                reject(new Error(message.error.message));\n            } else {\n                resolve(message.result);\n            }\n        }\n    }\n}\n\nmodule.exports = AndroidMCPClient;\n</code></pre> <p>This transport configuration guide provides comprehensive coverage of both WebSocket and HTTP/SSE transports, including practical examples, troubleshooting tips, and integration patterns for connecting various MCP clients to your Android MCP server.</p>"},{"location":"usage/","title":"Usage Guide","text":"<p>This guide covers common usage patterns and provides comprehensive examples for working with the Android MCP SDK.</p>"},{"location":"usage/#basic-server-operations","title":"Basic Server Operations","text":""},{"location":"usage/#starting-and-stopping-the-server","title":"Starting and Stopping the Server","text":"<pre><code>val manager = McpStartup.getManager()\n\n// Start server asynchronously (recommended)\nmanager.startServerAsync()\n\n// Start server with coroutines for error handling\nlifecycleScope.launch {\n    try {\n        manager.startServer().getOrThrow()\n        Log.d(\"MCP\", \"Server started successfully\")\n    } catch (e: Exception) {\n        Log.e(\"MCP\", \"Failed to start server\", e)\n    }\n}\n\n// Stop server\nlifecycleScope.launch {\n    manager.stopServer().getOrThrow()\n    Log.d(\"MCP\", \"Server stopped\")\n}\n\n// Check server status\nval isRunning = manager.isServerRunning()\nLog.d(\"MCP\", \"Server running: $isRunning\")\n</code></pre>"},{"location":"usage/#server-information","title":"Server Information","text":"<pre><code>val manager = McpStartup.getManager()\n\n// Get SDK version\nval sdkVersion = manager.getMcpSdkVersion()\nLog.d(\"MCP\", \"SDK Version: $sdkVersion\")\n\n// Get transport information\nval transportInfo = manager.getTransportInfo()\nLog.d(\"MCP\", \"Transport info: $transportInfo\")\n\n// Check if MCP SDK integration is available\nval hasIntegration = manager.hasSDKIntegration()\nLog.d(\"MCP\", \"SDK Integration available: $hasIntegration\")\n</code></pre>"},{"location":"usage/#adding-custom-tools","title":"Adding Custom Tools","text":"<p>Tools are functions that AI models can call to perform actions or retrieve information.</p>"},{"location":"usage/#simple-tools","title":"Simple Tools","text":"<p>For basic tools with minimal configuration:</p> <pre><code>val manager = McpStartup.getManager()\n\n// Add a simple calculation tool\nmanager.addSimpleTool(\n    name = \"calculate_sum\",\n    description = \"Calculate the sum of two numbers\",\n    parameters = mapOf(\n        \"a\" to \"number\",\n        \"b\" to \"number\"\n    )\n) { arguments -&gt;\n    val a = arguments[\"a\"] as? Number ?: 0\n    val b = arguments[\"b\"] as? Number ?: 0\n    \"Sum: ${a.toDouble() + b.toDouble()}\"\n}\n\n// Add a text processing tool\nmanager.addSimpleTool(\n    name = \"reverse_text\",\n    description = \"Reverse the input text\",\n    parameters = mapOf(\"text\" to \"string\")\n) { arguments -&gt;\n    val text = arguments[\"text\"] as? String ?: \"\"\n    text.reversed()\n}\n</code></pre>"},{"location":"usage/#advanced-mcp-tools","title":"Advanced MCP Tools","text":"<p>For tools that need full MCP protocol support:</p> <pre><code>// Create a complex tool with proper JSON schema\nval complexTool = Tool(\n    name = \"process_data\",\n    description = \"Process data with various operations\",\n    inputSchema = Tool.Input(\n        properties = buildJsonObject {\n            put(\"operation\", buildJsonObject {\n                put(\"type\", JsonPrimitive(\"string\"))\n                put(\"enum\", buildJsonArray {\n                    add(JsonPrimitive(\"encode\"))\n                    add(JsonPrimitive(\"decode\"))\n                    add(JsonPrimitive(\"hash\"))\n                    add(JsonPrimitive(\"format\"))\n                })\n                put(\"description\", JsonPrimitive(\"The operation to perform\"))\n            })\n            put(\"data\", buildJsonObject {\n                put(\"type\", JsonPrimitive(\"string\"))\n                put(\"description\", JsonPrimitive(\"The data to process\"))\n            })\n            put(\"options\", buildJsonObject {\n                put(\"type\", JsonPrimitive(\"object\"))\n                put(\"description\", JsonPrimitive(\"Additional options\"))\n                put(\"properties\", buildJsonObject {\n                    put(\"encoding\", buildJsonObject {\n                        put(\"type\", JsonPrimitive(\"string\"))\n                        put(\"default\", JsonPrimitive(\"UTF-8\"))\n                    })\n                })\n            })\n        },\n        required = listOf(\"operation\", \"data\")\n    )\n)\n\nmanager.addMcpTool(complexTool) { arguments -&gt;\n    val operation = arguments[\"operation\"] as? String ?: \"encode\"\n    val data = arguments[\"data\"] as? String ?: \"\"\n    val options = arguments[\"options\"] as? Map&lt;*, *&gt; ?: emptyMap&lt;String, Any&gt;()\n\n    val result = when (operation) {\n        \"encode\" -&gt; {\n            val encoding = options[\"encoding\"] as? String ?: \"UTF-8\"\n            java.util.Base64.getEncoder().encodeToString(data.toByteArray(charset(encoding)))\n        }\n        \"decode\" -&gt; {\n            try {\n                String(java.util.Base64.getDecoder().decode(data))\n            } catch (e: Exception) {\n                \"Error: Invalid base64 data\"\n            }\n        }\n        \"hash\" -&gt; {\n            val digest = java.security.MessageDigest.getInstance(\"SHA-256\")\n            digest.digest(data.toByteArray()).joinToString(\"\") { \"%02x\".format(it) }\n        }\n        \"format\" -&gt; {\n            // Simple JSON formatting\n            try {\n                val json = kotlinx.serialization.json.Json.parseToJsonElement(data)\n                kotlinx.serialization.json.Json { prettyPrint = true }.encodeToString(json)\n            } catch (e: Exception) {\n                \"Error: Invalid JSON data\"\n            }\n        }\n        else -&gt; \"Error: Unknown operation '$operation'\"\n    }\n\n    CallToolResult(\n        content = listOf(TextContent(text = result)),\n        isError = result.startsWith(\"Error:\")\n    )\n}\n</code></pre>"},{"location":"usage/#android-specific-tools","title":"Android-Specific Tools","text":"<p>Create tools that leverage Android capabilities:</p> <pre><code>// File operations tool\nmanager.addMcpTool(\n    Tool(\n        name = \"file_operations\",\n        description = \"Perform file operations within app directory\",\n        inputSchema = Tool.Input(\n            properties = buildJsonObject {\n                put(\"action\", buildJsonObject {\n                    put(\"type\", JsonPrimitive(\"string\"))\n                    put(\"enum\", buildJsonArray {\n                        add(JsonPrimitive(\"list\"))\n                        add(JsonPrimitive(\"read\"))\n                        add(JsonPrimitive(\"write\"))\n                        add(JsonPrimitive(\"delete\"))\n                    })\n                })\n                put(\"path\", buildJsonObject {\n                    put(\"type\", JsonPrimitive(\"string\"))\n                    put(\"description\", JsonPrimitive(\"Relative path within app directory\"))\n                })\n                put(\"content\", buildJsonObject {\n                    put(\"type\", JsonPrimitive(\"string\"))\n                    put(\"description\", JsonPrimitive(\"Content for write operations\"))\n                })\n            },\n            required = listOf(\"action\", \"path\")\n        )\n    )\n) { arguments -&gt;\n    val action = arguments[\"action\"] as? String ?: \"list\"\n    val path = arguments[\"path\"] as? String ?: \"\"\n    val content = arguments[\"content\"] as? String ?: \"\"\n\n    try {\n        val appDir = File(context.filesDir, path)\n\n        val result = when (action) {\n            \"list\" -&gt; {\n                if (appDir.isDirectory) {\n                    appDir.listFiles()?.joinToString(\"\\n\") { it.name } ?: \"Empty directory\"\n                } else {\n                    \"Not a directory\"\n                }\n            }\n            \"read\" -&gt; {\n                if (appDir.exists() &amp;&amp; appDir.isFile) {\n                    appDir.readText()\n                } else {\n                    \"File not found\"\n                }\n            }\n            \"write\" -&gt; {\n                appDir.parentFile?.mkdirs()\n                appDir.writeText(content)\n                \"File written successfully\"\n            }\n            \"delete\" -&gt; {\n                if (appDir.exists()) {\n                    if (appDir.delete()) \"File deleted\" else \"Failed to delete\"\n                } else {\n                    \"File not found\"\n                }\n            }\n            else -&gt; \"Unknown action: $action\"\n        }\n\n        CallToolResult(\n            content = listOf(TextContent(text = result)),\n            isError = false\n        )\n    } catch (e: Exception) {\n        CallToolResult(\n            content = listOf(TextContent(text = \"Error: ${e.message}\")),\n            isError = true\n        )\n    }\n}\n</code></pre>"},{"location":"usage/#adding-custom-resources","title":"Adding Custom Resources","text":"<p>Resources provide file-like data that clients can read and potentially subscribe to for updates.</p>"},{"location":"usage/#simple-file-resources","title":"Simple File Resources","text":"<pre><code>val manager = McpStartup.getManager()\n\n// Add a static file resource\nmanager.addFileResource(\n    uri = \"app://config/settings.json\",\n    name = \"App Settings\",\n    description = \"Application configuration settings\",\n    filePath = File(context.filesDir, \"settings.json\").absolutePath,\n    mimeType = \"application/json\"\n)\n\n// Add app info as a resource\nmanager.addFileResource(\n    uri = \"app://info/manifest.xml\",\n    name = \"App Manifest\",\n    description = \"Application manifest information\",\n    filePath = context.packageManager.getApplicationInfo(context.packageName, 0).sourceDir,\n    mimeType = \"application/xml\"\n)\n</code></pre>"},{"location":"usage/#dynamic-resources","title":"Dynamic Resources","text":"<pre><code>// Create a dynamic resource that provides real-time data\nval statusResource = Resource(\n    uri = \"app://status/realtime\",\n    name = \"Real-time Status\",\n    description = \"Current application status and metrics\",\n    mimeType = \"application/json\"\n)\n\nmanager.addMcpResource(statusResource) {\n    val status = buildJsonObject {\n        put(\"timestamp\", JsonPrimitive(System.currentTimeMillis()))\n        put(\"uptime\", JsonPrimitive(SystemClock.elapsedRealtime()))\n        put(\"memory\", buildJsonObject {\n            val runtime = Runtime.getRuntime()\n            put(\"total\", JsonPrimitive(runtime.totalMemory()))\n            put(\"free\", JsonPrimitive(runtime.freeMemory()))\n            put(\"max\", JsonPrimitive(runtime.maxMemory()))\n            put(\"used\", JsonPrimitive(runtime.totalMemory() - runtime.freeMemory()))\n        })\n        put(\"threads\", JsonPrimitive(Thread.activeCount()))\n        put(\"battery\", buildJsonObject {\n            val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager\n            val level = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\n            put(\"level\", JsonPrimitive(level))\n            put(\"charging\", JsonPrimitive(batteryManager.isCharging))\n        })\n    }\n\n    AndroidResourceContent(\n        uri = \"app://status/realtime\",\n        text = status.toString(),\n        mimeType = \"application/json\"\n    )\n}\n\n// Subscribe to resource updates\nmanager.subscribeMcpResource(\"app://status/realtime\")\n</code></pre>"},{"location":"usage/#database-resources","title":"Database Resources","text":"<pre><code>// Expose database tables as resources\nval dbResource = Resource(\n    uri = \"app://database/users\",\n    name = \"User Database\",\n    description = \"User data from local database\",\n    mimeType = \"application/json\"\n)\n\nmanager.addMcpResource(dbResource) {\n    // Query your Room database or SQLite\n    val users = userDao.getAllUsers() // Assuming you have a DAO\n\n    val jsonUsers = buildJsonArray {\n        users.forEach { user -&gt;\n            add(buildJsonObject {\n                put(\"id\", JsonPrimitive(user.id))\n                put(\"name\", JsonPrimitive(user.name))\n                put(\"email\", JsonPrimitive(user.email))\n                put(\"created\", JsonPrimitive(user.createdAt.toString()))\n            })\n        }\n    }\n\n    AndroidResourceContent(\n        uri = \"app://database/users\",\n        text = jsonUsers.toString(),\n        mimeType = \"application/json\"\n    )\n}\n</code></pre>"},{"location":"usage/#adding-custom-prompts","title":"Adding Custom Prompts","text":"<p>Prompts provide template-based text generation with dynamic arguments.</p>"},{"location":"usage/#simple-prompts","title":"Simple Prompts","text":"<pre><code>val manager = McpStartup.getManager()\n\n// Add a code review prompt\nmanager.addSimplePrompt(\n    name = \"review_code\",\n    description = \"Generate a code review for the provided code\",\n    arguments = listOf(\n        PromptArgument(\n            name = \"code\",\n            description = \"The code to review\",\n            required = true\n        ),\n        PromptArgument(\n            name = \"language\",\n            description = \"Programming language (default: kotlin)\",\n            required = false\n        ),\n        PromptArgument(\n            name = \"focus\",\n            description = \"Areas to focus on (performance, security, style)\",\n            required = false\n        )\n    )\n) { arguments -&gt;\n    val code = arguments[\"code\"] as? String ?: \"\"\n    val language = arguments[\"language\"] as? String ?: \"kotlin\"\n    val focus = arguments[\"focus\"] as? String ?: \"general best practices\"\n\n    \"\"\"\n    Please review the following $language code with focus on $focus:\n\n    ```$language\n    $code\n    ```\n\n    Provide feedback on:\n    1. Code quality and readability\n    2. Potential bugs or issues\n    3. Performance considerations\n    4. Security implications\n    5. Adherence to best practices\n    6. Suggestions for improvement\n\n    Format your response with specific line references where applicable.\n    \"\"\".trimIndent()\n}\n</code></pre>"},{"location":"usage/#advanced-mcp-prompts","title":"Advanced MCP Prompts","text":"<pre><code>// Create a complex prompt with multiple messages\nval logAnalysisPrompt = Prompt(\n    name = \"analyze_android_logs\",\n    description = \"Analyze Android application logs for issues and patterns\",\n    arguments = listOf(\n        PromptArgument(\n            name = \"logs\",\n            description = \"The log content to analyze\",\n            required = true\n        ),\n        PromptArgument(\n            name = \"time_range\",\n            description = \"Time range for analysis (e.g., 'last 24 hours')\",\n            required = false\n        ),\n        PromptArgument(\n            name = \"severity\",\n            description = \"Minimum log severity to consider (DEBUG, INFO, WARN, ERROR)\",\n            required = false\n        )\n    )\n)\n\nmanager.addMcpPrompt(logAnalysisPrompt) { arguments -&gt;\n    val logs = arguments[\"logs\"] as? String ?: \"\"\n    val timeRange = arguments[\"time_range\"] as? String ?: \"recent\"\n    val severity = arguments[\"severity\"] as? String ?: \"WARN\"\n\n    GetPromptResult(\n        description = \"Analyze Android logs for patterns and issues\",\n        messages = listOf(\n            PromptMessage(\n                role = MessageRole.USER,\n                content = TextContent(\n                    text = \"\"\"\n                    You are an expert Android developer and log analyst. Please analyze the following Android application logs for the $timeRange time period, focusing on $severity level and above.\n\n                    Look for:\n                    1. Critical errors and exceptions\n                    2. Performance bottlenecks\n                    3. Memory leaks or OutOfMemoryErrors\n                    4. ANR (Application Not Responding) events\n                    5. Security-related warnings\n                    6. Unusual patterns or repeated issues\n                    7. Potential root causes\n\n                    Logs to analyze:\n                    ```\n                    $logs\n                    ```\n\n                    Provide a structured analysis with:\n                    - Summary of findings\n                    - Critical issues requiring immediate attention\n                    - Performance recommendations\n                    - Security considerations\n                    - Suggested fixes or investigations\n                    \"\"\".trimIndent()\n                )\n            )\n        )\n    )\n}\n</code></pre>"},{"location":"usage/#lifecycle-management","title":"Lifecycle Management","text":""},{"location":"usage/#configuring-lifecycle-behavior","title":"Configuring Lifecycle Behavior","text":"<pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        val manager = McpStartup.initializeManually(this)\n\n        // Configure comprehensive lifecycle management\n        manager.initializeLifecycleManagement(\n            application = this,\n            config = McpLifecycleManager.LifecycleConfig(\n                autoStartOnAppStart = true,           // Start server when app starts\n                autoStopOnAppStop = false,            // Keep running in background\n                restartOnAppReturn = true,            // Restart when returning from background\n                pauseOnBackground = false,            // Don't pause when app goes to background\n                stopOnLastActivityDestroyed = false   // Don't stop when all activities are destroyed\n            )\n        )\n    }\n}\n</code></pre>"},{"location":"usage/#monitoring-lifecycle-state","title":"Monitoring Lifecycle State","text":"<pre><code>class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val manager = McpStartup.getManager()\n        val lifecycleState = manager.getLifecycleState()\n\n        Log.d(\"MCP\", \"App in background: ${lifecycleState.isAppInBackground}\")\n        Log.d(\"MCP\", \"Active activities: ${lifecycleState.activeActivities}\")\n        Log.d(\"MCP\", \"Server running: ${lifecycleState.isServerRunning}\")\n        Log.d(\"MCP\", \"Auto-start enabled: ${lifecycleState.config.autoStartOnAppStart}\")\n\n        // Update configuration dynamically\n        if (shouldKeepServerRunning()) {\n            manager.updateLifecycleConfig(\n                lifecycleState.config.copy(\n                    autoStopOnAppStop = false,\n                    stopOnLastActivityDestroyed = false\n                )\n            )\n        }\n    }\n\n    private fun shouldKeepServerRunning(): Boolean {\n        // Your logic to determine if server should keep running\n        return true\n    }\n}\n</code></pre>"},{"location":"usage/#transport-layer-usage","title":"Transport Layer Usage","text":""},{"location":"usage/#websocket-transport","title":"WebSocket Transport","text":"<pre><code>val manager = McpStartup.getManager()\n\n// Get WebSocket transport information\nval transportInfo = manager.getTransportInfo()\nLog.d(\"MCP\", \"WebSocket endpoint: ws://localhost:8080/mcp\")\n\n// Send custom messages to connected clients\nlifecycleScope.launch {\n    val message = buildJsonObject {\n        put(\"jsonrpc\", JsonPrimitive(\"2.0\"))\n        put(\"method\", JsonPrimitive(\"notification/custom\"))\n        put(\"params\", buildJsonObject {\n            put(\"message\", JsonPrimitive(\"Hello from Android!\"))\n            put(\"timestamp\", JsonPrimitive(System.currentTimeMillis()))\n        })\n    }\n\n    manager.broadcastMessage(message.toString())\n}\n</code></pre>"},{"location":"usage/#httpsse-transport","title":"HTTP/SSE Transport","text":"<pre><code>// HTTP endpoints are automatically available:\n// POST http://localhost:8081/mcp/message - for client-to-server messages\n// GET  http://localhost:8081/mcp/events  - for server-to-client events (SSE)\n// GET  http://localhost:8081/mcp/status  - for transport status\n\n// Test endpoints from adb\n// adb forward tcp:8081 tcp:8081\n// curl -X POST http://localhost:8081/mcp/message -H \"Content-Type: application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1}'\n</code></pre>"},{"location":"usage/#error-handling","title":"Error Handling","text":""},{"location":"usage/#robust-error-handling-patterns","title":"Robust Error Handling Patterns","text":"<pre><code>val manager = McpStartup.getManager()\n\n// Safe server operations with proper error handling\nlifecycleScope.launch {\n    manager.startServer().fold(\n        onSuccess = {\n            Log.d(\"MCP\", \"Server started successfully\")\n\n            // Add tools with error handling\n            try {\n                manager.addSimpleTool(\n                    name = \"safe_operation\",\n                    description = \"A safe operation with error handling\",\n                    parameters = mapOf(\"input\" to \"string\")\n                ) { arguments -&gt;\n                    try {\n                        val input = arguments[\"input\"] as? String ?: \"\"\n                        // Your operation here\n                        \"Processed: $input\"\n                    } catch (e: Exception) {\n                        Log.e(\"MCP\", \"Tool execution failed\", e)\n                        \"Error: ${e.message}\"\n                    }\n                }\n            } catch (e: Exception) {\n                Log.e(\"MCP\", \"Failed to add tool\", e)\n            }\n        },\n        onFailure = { exception -&gt;\n            Log.e(\"MCP\", \"Failed to start server\", exception)\n            // Handle startup failure\n        }\n    )\n}\n</code></pre>"},{"location":"usage/#best-practices","title":"Best Practices","text":""},{"location":"usage/#tool-design","title":"Tool Design","text":"<ol> <li>Clear naming: Use descriptive, action-oriented names</li> <li>Comprehensive descriptions: Help AI understand when to use the tool</li> <li>Proper schemas: Define clear parameter types and requirements</li> <li>Error handling: Always handle and report errors gracefully</li> <li>Validation: Validate input parameters before processing</li> </ol>"},{"location":"usage/#resource-management","title":"Resource Management","text":"<ol> <li>Efficient data: Only expose necessary data, avoid large responses</li> <li>Security: Never expose sensitive information</li> <li>Updates: Use subscriptions for dynamic resources</li> <li>Caching: Cache expensive operations when appropriate</li> </ol>"},{"location":"usage/#performance","title":"Performance","text":"<ol> <li>Async operations: Use coroutines for I/O operations</li> <li>Background threads: Don't block the main thread</li> <li>Memory management: Be mindful of memory usage in tools and resources</li> <li>Connection limits: Monitor transport connections and resource usage</li> </ol>"},{"location":"usage/#security","title":"Security","text":"<ol> <li>Input validation: Always validate tool inputs</li> <li>File access: Restrict file operations to safe directories</li> <li>Permissions: Request only necessary Android permissions</li> <li>Data exposure: Be careful about what data you expose via resources</li> </ol>"},{"location":"ai/implementation-summary/","title":"Android MCP SDK - Complete Implementation Summary","text":""},{"location":"ai/implementation-summary/#overview","title":"Overview","text":"<p>This document summarizes the comprehensive implementation of the Android MCP SDK that provides full Model Context Protocol (MCP) specification support for Android applications.</p>"},{"location":"ai/implementation-summary/#what-weve-accomplished","title":"What We've Accomplished","text":""},{"location":"ai/implementation-summary/#1-complete-mcp-types-system-mcptypeskt","title":"1. Complete MCP Types System (<code>McpTypes.kt</code>)","text":"<p>Implemented all core MCP data structures:</p> <ul> <li>Content Types: <code>McpContent</code>, <code>TextContent</code>, <code>ImageContent</code>, <code>EmbeddedResource</code></li> <li>Resource Data: <code>ResourceData</code> for both text and binary content</li> <li>Messaging: <code>PromptMessage</code>, <code>MessageRole</code> enum</li> <li>Capabilities: <code>ServerCapabilities</code>, <code>PromptsCapability</code>, <code>ResourcesCapability</code>,   <code>ToolsCapability</code></li> <li>Client Support: <code>ClientCapabilities</code>, <code>RootsCapability</code>, <code>SamplingCapability</code></li> <li>Sampling: <code>SamplingRequest</code>, <code>ModelPreferences</code>, <code>ModelHint</code></li> <li>Infrastructure: <code>Implementation</code>, <code>Root</code>, <code>ToolCallResult</code></li> </ul>"},{"location":"ai/implementation-summary/#2-comprehensive-tool-provider-toolproviderkt","title":"2. Comprehensive Tool Provider (<code>ToolProvider.kt</code>)","text":"<p>Built-in Android-specific tools:</p> <ul> <li>Device Information: Complete device details including model, manufacturer, Android version</li> <li>Application Information: App details, version info, package metadata</li> <li>System Time: Multiple time formats with timezone support</li> <li>Memory Information: System and app memory usage statistics</li> <li>Battery Information: Comprehensive battery status and health data</li> </ul> <p>Features:</p> <ul> <li>Custom tool registration with type-safe handlers</li> <li>Proper JSON schema definitions for tool parameters</li> <li>Error handling and validation</li> <li>Thread-safe concurrent tool management</li> </ul>"},{"location":"ai/implementation-summary/#3-advanced-resource-provider-resourceproviderkt","title":"3. Advanced Resource Provider (<code>ResourceProvider.kt</code>)","text":"<p>Built-in resources:</p> <ul> <li>Application Info Resource: <code>android://app/info</code></li> <li>Device Info Resource: <code>android://device/info</code></li> <li>File System Resources: Secure file access within app boundaries</li> </ul> <p>Features:</p> <ul> <li>Resource templates for dynamic content generation</li> <li>Subscription support for resource updates</li> <li>Security boundaries for file access</li> <li>Custom resource registration</li> <li>MIME type support for various content types</li> </ul>"},{"location":"ai/implementation-summary/#4-intelligent-prompt-provider-promptproviderkt","title":"4. Intelligent Prompt Provider (<code>PromptProvider.kt</code>)","text":"<p>Built-in Android development prompts:</p> <ul> <li>Log Analysis: <code>analyze_android_log</code> - Analyze Android logs for issues</li> <li>Code Generation: <code>generate_android_code</code> - Generate Android code with best practices</li> <li>Error Explanation: <code>explain_android_error</code> - Explain and solve Android errors</li> <li>Test Creation: <code>create_android_test</code> - Create comprehensive test suites</li> <li>Code Review: <code>review_android_code</code> - Review code for quality and best practices</li> </ul> <p>Features:</p> <ul> <li>Dynamic argument substitution</li> <li>Rich prompt templates with context</li> <li>Custom prompt registration</li> <li>Android-specific domain knowledge</li> </ul>"},{"location":"ai/implementation-summary/#5-comprehensive-mcp-server-comprehensivemcpserverkt","title":"5. Comprehensive MCP Server (<code>ComprehensiveMcpServer.kt</code>)","text":"<p>Complete MCP server implementation:</p> <ul> <li>Full Lifecycle Management: Initialize, start, stop with proper state management</li> <li>All MCP Capabilities: Tools, resources, prompts, roots, sampling framework</li> <li>Thread Safety: Atomic operations and coroutine-based async support</li> <li>Error Handling: Robust error handling with Result types</li> <li>Default Roots: Automatic setup of app file directories</li> </ul> <p>Features:</p> <ul> <li>Android Context integration</li> <li>Server capability negotiation</li> <li>Custom feature registration</li> <li>Comprehensive server information</li> </ul>"},{"location":"ai/implementation-summary/#6-enhanced-server-manager-mcpservermanagerkt","title":"6. Enhanced Server Manager (<code>McpServerManager.kt</code>)","text":"<p>Thread-safe singleton manager:</p> <ul> <li>Simplified Initialization: Easy setup with sensible defaults</li> <li>Complete API: All MCP operations exposed through clean interface</li> <li>Error Handling: Graceful handling of uninitialized states</li> <li>Background Operations: Async server startup with proper coroutine support</li> </ul>"},{"location":"ai/implementation-summary/#7-comprehensive-testing-suite","title":"7. Comprehensive Testing Suite","text":"<p>Complete test coverage:</p> <ul> <li>Type Tests: All MCP types and data structures</li> <li>Unit Tests: Core functionality and error handling</li> <li>Integration Tests: Manager and server interaction</li> <li>Edge Cases: Uninitialized states and error conditions</li> </ul>"},{"location":"ai/implementation-summary/#mcp-specification-compliance","title":"MCP Specification Compliance","text":""},{"location":"ai/implementation-summary/#fully-implemented-features","title":"\u2705 Fully Implemented Features","text":"<ol> <li> <p>Tools</p> <ul> <li>Tool discovery and listing</li> <li>Tool invocation with parameters</li> <li>Custom tool registration</li> <li>Error handling and validation</li> <li>Built-in Android-specific tools</li> </ul> </li> <li> <p>Resources</p> <ul> <li>Resource discovery and listing</li> <li>Resource content reading</li> <li>Resource templates for dynamic content</li> <li>Subscription support for updates</li> <li>Custom resource registration</li> <li>Built-in Android resources</li> </ul> </li> <li> <p>Prompts</p> <ul> <li>Prompt discovery and listing</li> <li>Dynamic prompt generation with arguments</li> <li>Custom prompt registration</li> <li>Built-in Android development prompts</li> <li>Multi-message sequences</li> </ul> </li> <li> <p>Roots</p> <ul> <li>Root directory management</li> <li>Filesystem boundary definition</li> <li>Custom root registration</li> <li>Default app directory roots</li> </ul> </li> <li> <p>Server Capabilities</p> <ul> <li>Capability negotiation</li> <li>Feature advertisement</li> <li>Client capability detection</li> </ul> </li> </ol>"},{"location":"ai/implementation-summary/#framework-ready-features","title":"\ud83d\udea7 Framework Ready Features","text":"<ol> <li> <p>Sampling</p> <ul> <li>Complete data structures</li> <li>Request/response framework</li> <li>Model preference system</li> <li>Ready for client integration</li> </ul> </li> <li> <p>Notifications</p> <ul> <li>List change notifications</li> <li>Resource update notifications</li> <li>Framework ready for implementation</li> </ul> </li> </ol>"},{"location":"ai/implementation-summary/#usage-examples","title":"Usage Examples","text":""},{"location":"ai/implementation-summary/#basic-initialization","title":"Basic Initialization","text":"<pre><code>class MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // Initialize with default settings\n        McpServerManager.getInstance().initialize(this).getOrThrow()\n\n        // Or customize\n        McpServerManager.getInstance().initialize(\n            context = this,\n            serverName = \"My App MCP Server\",\n            serverVersion = \"2.0.0\"\n        ).getOrThrow()\n    }\n}\n</code></pre>"},{"location":"ai/implementation-summary/#starting-the-server","title":"Starting the Server","text":"<pre><code>// Async startup (recommended)\nMcpServerManager.getInstance().startServerAsync()\n\n// Or with coroutines\nlifecycleScope.launch {\n    McpServerManager.getInstance().startServer().getOrThrow()\n}\n</code></pre>"},{"location":"ai/implementation-summary/#adding-custom-tools","title":"Adding Custom Tools","text":"<pre><code>val customTool = Tool(\n    name = \"my_custom_tool\",\n    description = \"Does something awesome\",\n    inputSchema = Tool.Input(\n        properties = buildJsonObject {\n            put(\"parameter\", buildJsonObject {\n                put(\"type\", JsonPrimitive(\"string\"))\n                put(\"description\", JsonPrimitive(\"A parameter\"))\n            })\n        },\n        required = listOf(\"parameter\")\n    )\n)\n\nMcpServerManager.getInstance().addTool(customTool) { args -&gt;\n    val param = args[\"parameter\"] as String\n    ToolCallResult(\n        content = listOf(TextContent(text = \"Result: $param\")),\n        isError = false\n    )\n}\n</code></pre>"},{"location":"ai/implementation-summary/#adding-custom-resources","title":"Adding Custom Resources","text":"<pre><code>val resource = Resource(\n    uri = \"myapp://data/users\",\n    name = \"User Data\",\n    description = \"Current user information\"\n)\n\nMcpServerManager.getInstance().addResource(resource) {\n    ResourceContent(\n        uri = \"myapp://data/users\",\n        text = getCurrentUserDataAsJson(),\n        mimeType = \"application/json\"\n    )\n}\n</code></pre>"},{"location":"ai/implementation-summary/#adding-custom-prompts","title":"Adding Custom Prompts","text":"<pre><code>val prompt = Prompt(\n    name = \"generate_ui_test\",\n    description = \"Generate UI test for Android component\",\n    arguments = listOf(\n        PromptArgument(name = \"component\", description = \"UI component to test\", required = true)\n    )\n)\n\nMcpServerManager.getInstance().addPrompt(prompt) { args -&gt;\n    val component = args[\"component\"] as String\n    GetPromptResult(\n        description = \"Generate UI test for $component\",\n        messages = listOf(\n            PromptMessage(\n                role = MessageRole.USER,\n                content = TextContent(text = \"Generate a comprehensive UI test for $component...\")\n            )\n        )\n    )\n}\n</code></pre>"},{"location":"ai/implementation-summary/#architecture-benefits","title":"Architecture Benefits","text":""},{"location":"ai/implementation-summary/#for-android-developers","title":"For Android Developers","text":"<ul> <li>Zero Boilerplate: Simple initialization, everything works out of the box</li> <li>Type Safe: Strong typing throughout with Kotlin data classes</li> <li>Coroutine Ready: Full async support with proper coroutine integration</li> <li>Android Native: Deep integration with Android Context and lifecycle</li> </ul>"},{"location":"ai/implementation-summary/#for-mcp-clients","title":"For MCP Clients","text":"<ul> <li>Complete Compatibility: Full MCP specification support</li> <li>Rich Capabilities: All MCP features available</li> <li>Extensible: Easy to add custom tools, resources, and prompts</li> <li>Reliable: Robust error handling and state management</li> </ul>"},{"location":"ai/implementation-summary/#for-tool-integration","title":"For Tool Integration","text":"<ul> <li>Standardized: Use standard MCP protocol</li> <li>Discoverable: Tools and resources are automatically discoverable</li> <li>Flexible: Support for simple tools to complex workflows</li> <li>Contextual: Rich Android context available to all implementations</li> </ul>"},{"location":"ai/implementation-summary/#technical-specifications","title":"Technical Specifications","text":"<ul> <li>Minimum Android Version: API 29 (Android 10)</li> <li>Kotlin Version: 2.0.21</li> <li>MCP SDK Version: 0.5.0</li> <li>Coroutines: Full async/await support</li> <li>Thread Safety: All operations are thread-safe</li> <li>Memory Efficient: Lazy loading and proper resource management</li> </ul>"},{"location":"ai/implementation-summary/#development-workflow","title":"Development Workflow","text":""},{"location":"ai/implementation-summary/#building","title":"Building","text":"<pre><code>./gradlew :lib:compileDebugKotlin    # Compile library\n./gradlew :sample:assembleDebug      # Build sample app\n</code></pre>"},{"location":"ai/implementation-summary/#testing","title":"Testing","text":"<pre><code>./gradlew :lib:test                  # Run unit tests\n</code></pre>"},{"location":"ai/implementation-summary/#code-formatting","title":"Code Formatting","text":"<pre><code>./scripts/apply_ktfmt.sh            # Format all code\n./scripts/validate_ktfmt.sh         # Validate formatting\n</code></pre>"},{"location":"ai/implementation-summary/#validation","title":"Validation","text":"<pre><code>./scripts/validate_shell_scripts.sh # Validate shell scripts\n./scripts/validate_xml.sh           # Validate XML files\n</code></pre>"},{"location":"ai/implementation-summary/#future-enhancements","title":"Future Enhancements","text":""},{"location":"ai/implementation-summary/#transport-layer","title":"Transport Layer","text":"<ul> <li>HTTP/SSE transport for remote servers</li> <li>WebSocket transport for real-time communication</li> <li>Custom transport implementations</li> </ul>"},{"location":"ai/implementation-summary/#advanced-features","title":"Advanced Features","text":"<ul> <li>AndroidX Startup automatic initialization</li> <li>Annotation processing for automatic tool generation</li> <li>IDE plugin for development support</li> <li>Performance monitoring and metrics</li> </ul>"},{"location":"ai/implementation-summary/#enhanced-android-integration","title":"Enhanced Android Integration","text":"<ul> <li>Content Provider integration</li> <li>Service-based MCP servers</li> <li>Deep system integration tools</li> <li>Security and permissions framework</li> </ul>"},{"location":"ai/implementation-summary/#conclusion","title":"Conclusion","text":"<p>This implementation provides a complete, production-ready MCP SDK for Android that:</p> <ol> <li>Implements the full MCP specification with all core features</li> <li>Provides rich Android-specific functionality out of the box</li> <li>Offers a clean, type-safe API for easy integration</li> <li>Maintains high code quality with comprehensive testing</li> <li>Follows Android best practices for lifecycle and threading</li> <li>Enables powerful AI tool integration for Android apps</li> </ol> <p>The SDK is ready for production use and provides a solid foundation for building MCP-enabled Android applications that can seamlessly integrate with AI tools and development environments.</p>"},{"location":"ai/validation/","title":"Validation and Development Rules","text":"<p>This document contains all validation and development rules for the Android MCP SDK project.</p>"},{"location":"ai/validation/#project-overview","title":"Project Overview","text":"<p>This is an Android library project to enable running MCP Servers hosted by Android apps. The goal of the project is to expose an MCP server to an Android engineer running an MCP client on their adb connected workstation.</p>"},{"location":"ai/validation/#building","title":"Building","text":"<ul> <li>Build the library: <code>./gradlew :lib:compileDebugKotlin</code></li> <li>Build the project: <code>./gradlew build</code></li> </ul>"},{"location":"ai/validation/#android-studio-ide-actions","title":"Android Studio IDE Actions","text":"<p>When working in Android Studio, these action IDs can be used to perform IDE operations:</p> <ul> <li>Gradle Sync: Use action ID <code>Android.SyncProject</code> to synchronize the project with Gradle files</li> </ul>"},{"location":"ai/validation/#automatic-gradle-sync-rule","title":"Automatic Gradle Sync Rule","text":"<ul> <li>When to sync: If any Gradle version catalog (<code>gradle/libs.versions.toml</code>) or build files (   <code>build.gradle</code>, <code>build.gradle.kts</code>, <code>settings.gradle</code>, <code>settings.gradle.kts</code>) have changed, a   Gradle sync should be attempted if none has occurred within the last minute</li> <li>Files that trigger sync:</li> <li><code>gradle/libs.versions.toml</code></li> <li><code>build.gradle</code> / <code>build.gradle.kts</code> (any module)</li> <li><code>settings.gradle</code> / <code>settings.gradle.kts</code></li> <li><code>gradle.properties</code></li> </ul>"},{"location":"ai/validation/#code-formatting","title":"Code Formatting","text":"<p>ktfmt should be used for lint.</p>"},{"location":"ai/validation/#kotlin-formatting","title":"Kotlin Formatting","text":"<ul> <li>Format Kotlin code: <code>./scripts/ktfmt/apply_ktfmt.sh</code><ul> <li>Use <code>ONLY_TOUCHED_FILES=false</code> to format all files</li> </ul> </li> <li>Validate Kotlin formatting: <code>./scripts/ktfmt/validate_ktfmt.sh</code><ul> <li>Use <code>ONLY_TOUCHED_FILES=false</code> to check all files</li> </ul> </li> <li>Install ktfmt if missing: <code>./scripts/ktfmt/install_ktfmt.sh</code><ul> <li>Or set <code>INSTALL_KTFMT_WHEN_MISSING=true</code> when running other scripts</li> </ul> </li> </ul>"},{"location":"ai/validation/#validation-scripts","title":"Validation Scripts","text":""},{"location":"ai/validation/#shell-scripts","title":"Shell Scripts","text":"<ul> <li>Validate shell scripts: <code>./scripts/shellcheck/validate_shell_scripts.sh</code></li> </ul>"},{"location":"ai/validation/#xml-files","title":"XML Files","text":"<ul> <li>Validate XML files: <code>./scripts/xml/validate_xml.sh</code></li> </ul>"},{"location":"ai/validation/#git-state","title":"Git State","text":"<ul> <li>Check git clean state: <code>./scripts/git/git_assert_clean_state.sh</code></li> </ul>"},{"location":"ai/validation/#installation-scripts","title":"Installation Scripts","text":""},{"location":"ai/validation/#all-requirements","title":"All Requirements","text":"<ul> <li>Install all requirements at once: <code>./scripts/install_all_requirements.sh</code></li> </ul>"},{"location":"ai/validation/#individual-tools","title":"Individual Tools","text":"<ul> <li>Install ripgrep if missing: <code>./scripts/ripgrep/install_ripgrep.sh</code><ul> <li>Or set <code>INSTALL_RIPGREP_WHEN_MISSING=true</code> when running other scripts</li> </ul> </li> </ul>"},{"location":"ai/validation/#github-actions-testing-with-act","title":"GitHub Actions Testing with act","text":"<p>act should be used for local GitHub Actions testing.</p>"},{"location":"ai/validation/#installation","title":"Installation","text":"<ul> <li>Install act if missing: <code>./scripts/act/install_act.sh</code><ul> <li>Or set <code>INSTALL_ACT_WHEN_MISSING=true</code> when running other scripts</li> </ul> </li> </ul>"},{"location":"ai/validation/#usage","title":"Usage","text":"<ul> <li>List available GitHub Actions jobs: <code>./scripts/act/act_list.sh</code></li> <li>Validate GitHub Actions workflows locally: <code>./scripts/act/validate_act.sh</code><ul> <li>Use <code>ACT_JOB=job-name</code> for specific jobs</li> </ul> </li> <li>Run GitHub Actions workflows locally: <code>./scripts/act/apply_act.sh</code><ul> <li>Use <code>ACT_EVENT=pull_request</code>, <code>ACT_JOB=job-name</code> for specific tests</li> </ul> </li> </ul>"},{"location":"ai/validation/#examples","title":"Examples","text":"<pre><code>ACT_JOB=ktfmt ./scripts/act/validate_act.sh\nACT_EVENT=pull_request ./scripts/act/apply_act.sh\n</code></pre>"},{"location":"ai/validation/#custom-dockerfile","title":"Custom Dockerfile","text":"<ul> <li>Use custom Dockerfile for act: <code>USE_CUSTOM_DOCKERFILE=true ./scripts/act/validate_act.sh</code></li> </ul>"},{"location":"ai/validation/#important-notes","title":"Important Notes","text":"<ul> <li>When making changes to .github/workflows files: Always test locally with act before pushing</li> <li>CI Environment: The ci/Dockerfile provides a complete Android development environment with   Azul JDK 23, Android SDK, ktfmt, act, xmlstarlet, and shellcheck (optional)</li> </ul>"}]}